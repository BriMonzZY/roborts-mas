// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: armor_detection.proto

#ifndef PROTOBUF_INCLUDED_armor_5fdetection_2eproto
#define PROTOBUF_INCLUDED_armor_5fdetection_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_armor_5fdetection_2eproto 

namespace protobuf_armor_5fdetection_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_armor_5fdetection_2eproto
namespace roborts_detection {
class ArmorDetectionAlgorithms;
class ArmorDetectionAlgorithmsDefaultTypeInternal;
extern ArmorDetectionAlgorithmsDefaultTypeInternal _ArmorDetectionAlgorithms_default_instance_;
class CameraGimbalTransform;
class CameraGimbalTransformDefaultTypeInternal;
extern CameraGimbalTransformDefaultTypeInternal _CameraGimbalTransform_default_instance_;
class ProjectileModelInfo;
class ProjectileModelInfoDefaultTypeInternal;
extern ProjectileModelInfoDefaultTypeInternal _ProjectileModelInfo_default_instance_;
}  // namespace roborts_detection
namespace google {
namespace protobuf {
template<> ::roborts_detection::ArmorDetectionAlgorithms* Arena::CreateMaybeMessage<::roborts_detection::ArmorDetectionAlgorithms>(Arena*);
template<> ::roborts_detection::CameraGimbalTransform* Arena::CreateMaybeMessage<::roborts_detection::CameraGimbalTransform>(Arena*);
template<> ::roborts_detection::ProjectileModelInfo* Arena::CreateMaybeMessage<::roborts_detection::ProjectileModelInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace roborts_detection {

// ===================================================================

class CameraGimbalTransform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_detection.CameraGimbalTransform) */ {
 public:
  CameraGimbalTransform();
  virtual ~CameraGimbalTransform();

  CameraGimbalTransform(const CameraGimbalTransform& from);

  inline CameraGimbalTransform& operator=(const CameraGimbalTransform& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraGimbalTransform(CameraGimbalTransform&& from) noexcept
    : CameraGimbalTransform() {
    *this = ::std::move(from);
  }

  inline CameraGimbalTransform& operator=(CameraGimbalTransform&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraGimbalTransform& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraGimbalTransform* internal_default_instance() {
    return reinterpret_cast<const CameraGimbalTransform*>(
               &_CameraGimbalTransform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CameraGimbalTransform* other);
  friend void swap(CameraGimbalTransform& a, CameraGimbalTransform& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraGimbalTransform* New() const final {
    return CreateMaybeMessage<CameraGimbalTransform>(NULL);
  }

  CameraGimbalTransform* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CameraGimbalTransform>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CameraGimbalTransform& from);
  void MergeFrom(const CameraGimbalTransform& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraGimbalTransform* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float offset_x = 1;
  bool has_offset_x() const;
  void clear_offset_x();
  static const int kOffsetXFieldNumber = 1;
  float offset_x() const;
  void set_offset_x(float value);

  // required float offset_y = 2;
  bool has_offset_y() const;
  void clear_offset_y();
  static const int kOffsetYFieldNumber = 2;
  float offset_y() const;
  void set_offset_y(float value);

  // required float offset_z = 3;
  bool has_offset_z() const;
  void clear_offset_z();
  static const int kOffsetZFieldNumber = 3;
  float offset_z() const;
  void set_offset_z(float value);

  // required float offset_pitch = 4;
  bool has_offset_pitch() const;
  void clear_offset_pitch();
  static const int kOffsetPitchFieldNumber = 4;
  float offset_pitch() const;
  void set_offset_pitch(float value);

  // required float offset_yaw = 5;
  bool has_offset_yaw() const;
  void clear_offset_yaw();
  static const int kOffsetYawFieldNumber = 5;
  float offset_yaw() const;
  void set_offset_yaw(float value);

  // @@protoc_insertion_point(class_scope:roborts_detection.CameraGimbalTransform)
 private:
  void set_has_offset_x();
  void clear_has_offset_x();
  void set_has_offset_y();
  void clear_has_offset_y();
  void set_has_offset_z();
  void clear_has_offset_z();
  void set_has_offset_pitch();
  void clear_has_offset_pitch();
  void set_has_offset_yaw();
  void clear_has_offset_yaw();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float offset_x_;
  float offset_y_;
  float offset_z_;
  float offset_pitch_;
  float offset_yaw_;
  friend struct ::protobuf_armor_5fdetection_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProjectileModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_detection.ProjectileModelInfo) */ {
 public:
  ProjectileModelInfo();
  virtual ~ProjectileModelInfo();

  ProjectileModelInfo(const ProjectileModelInfo& from);

  inline ProjectileModelInfo& operator=(const ProjectileModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProjectileModelInfo(ProjectileModelInfo&& from) noexcept
    : ProjectileModelInfo() {
    *this = ::std::move(from);
  }

  inline ProjectileModelInfo& operator=(ProjectileModelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectileModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProjectileModelInfo* internal_default_instance() {
    return reinterpret_cast<const ProjectileModelInfo*>(
               &_ProjectileModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ProjectileModelInfo* other);
  friend void swap(ProjectileModelInfo& a, ProjectileModelInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProjectileModelInfo* New() const final {
    return CreateMaybeMessage<ProjectileModelInfo>(NULL);
  }

  ProjectileModelInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProjectileModelInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProjectileModelInfo& from);
  void MergeFrom(const ProjectileModelInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectileModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float init_v = 1;
  bool has_init_v() const;
  void clear_init_v();
  static const int kInitVFieldNumber = 1;
  float init_v() const;
  void set_init_v(float value);

  // optional float init_k = 2;
  bool has_init_k() const;
  void clear_init_k();
  static const int kInitKFieldNumber = 2;
  float init_k() const;
  void set_init_k(float value);

  // @@protoc_insertion_point(class_scope:roborts_detection.ProjectileModelInfo)
 private:
  void set_has_init_v();
  void clear_has_init_v();
  void set_has_init_k();
  void clear_has_init_k();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float init_v_;
  float init_k_;
  friend struct ::protobuf_armor_5fdetection_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArmorDetectionAlgorithms : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_detection.ArmorDetectionAlgorithms) */ {
 public:
  ArmorDetectionAlgorithms();
  virtual ~ArmorDetectionAlgorithms();

  ArmorDetectionAlgorithms(const ArmorDetectionAlgorithms& from);

  inline ArmorDetectionAlgorithms& operator=(const ArmorDetectionAlgorithms& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArmorDetectionAlgorithms(ArmorDetectionAlgorithms&& from) noexcept
    : ArmorDetectionAlgorithms() {
    *this = ::std::move(from);
  }

  inline ArmorDetectionAlgorithms& operator=(ArmorDetectionAlgorithms&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArmorDetectionAlgorithms& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArmorDetectionAlgorithms* internal_default_instance() {
    return reinterpret_cast<const ArmorDetectionAlgorithms*>(
               &_ArmorDetectionAlgorithms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ArmorDetectionAlgorithms* other);
  friend void swap(ArmorDetectionAlgorithms& a, ArmorDetectionAlgorithms& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArmorDetectionAlgorithms* New() const final {
    return CreateMaybeMessage<ArmorDetectionAlgorithms>(NULL);
  }

  ArmorDetectionAlgorithms* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArmorDetectionAlgorithms>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArmorDetectionAlgorithms& from);
  void MergeFrom(const ArmorDetectionAlgorithms& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArmorDetectionAlgorithms* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string name = 1;
  int name_size() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name(int index) const;
  ::std::string* mutable_name(int index);
  void set_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_name(int index, ::std::string&& value);
  #endif
  void set_name(int index, const char* value);
  void set_name(int index, const char* value, size_t size);
  ::std::string* add_name();
  void add_name(const ::std::string& value);
  #if LANG_CXX11
  void add_name(::std::string&& value);
  #endif
  void add_name(const char* value);
  void add_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // optional string selected_algorithm = 2;
  bool has_selected_algorithm() const;
  void clear_selected_algorithm();
  static const int kSelectedAlgorithmFieldNumber = 2;
  const ::std::string& selected_algorithm() const;
  void set_selected_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_selected_algorithm(::std::string&& value);
  #endif
  void set_selected_algorithm(const char* value);
  void set_selected_algorithm(const char* value, size_t size);
  ::std::string* mutable_selected_algorithm();
  ::std::string* release_selected_algorithm();
  void set_allocated_selected_algorithm(::std::string* selected_algorithm);

  // optional string camera_name = 4;
  bool has_camera_name() const;
  void clear_camera_name();
  static const int kCameraNameFieldNumber = 4;
  const ::std::string& camera_name() const;
  void set_camera_name(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_name(::std::string&& value);
  #endif
  void set_camera_name(const char* value);
  void set_camera_name(const char* value, size_t size);
  ::std::string* mutable_camera_name();
  ::std::string* release_camera_name();
  void set_allocated_camera_name(::std::string* camera_name);

  // required .roborts_detection.CameraGimbalTransform camera_gimbal_transform = 5;
  bool has_camera_gimbal_transform() const;
  void clear_camera_gimbal_transform();
  static const int kCameraGimbalTransformFieldNumber = 5;
  private:
  const ::roborts_detection::CameraGimbalTransform& _internal_camera_gimbal_transform() const;
  public:
  const ::roborts_detection::CameraGimbalTransform& camera_gimbal_transform() const;
  ::roborts_detection::CameraGimbalTransform* release_camera_gimbal_transform();
  ::roborts_detection::CameraGimbalTransform* mutable_camera_gimbal_transform();
  void set_allocated_camera_gimbal_transform(::roborts_detection::CameraGimbalTransform* camera_gimbal_transform);

  // optional .roborts_detection.ProjectileModelInfo projectile_model_info = 6;
  bool has_projectile_model_info() const;
  void clear_projectile_model_info();
  static const int kProjectileModelInfoFieldNumber = 6;
  private:
  const ::roborts_detection::ProjectileModelInfo& _internal_projectile_model_info() const;
  public:
  const ::roborts_detection::ProjectileModelInfo& projectile_model_info() const;
  ::roborts_detection::ProjectileModelInfo* release_projectile_model_info();
  ::roborts_detection::ProjectileModelInfo* mutable_projectile_model_info();
  void set_allocated_projectile_model_info(::roborts_detection::ProjectileModelInfo* projectile_model_info);

  // optional uint32 undetected_armor_delay = 3;
  bool has_undetected_armor_delay() const;
  void clear_undetected_armor_delay();
  static const int kUndetectedArmorDelayFieldNumber = 3;
  ::google::protobuf::uint32 undetected_armor_delay() const;
  void set_undetected_armor_delay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:roborts_detection.ArmorDetectionAlgorithms)
 private:
  void set_has_selected_algorithm();
  void clear_has_selected_algorithm();
  void set_has_undetected_armor_delay();
  void clear_has_undetected_armor_delay();
  void set_has_camera_name();
  void clear_has_camera_name();
  void set_has_camera_gimbal_transform();
  void clear_has_camera_gimbal_transform();
  void set_has_projectile_model_info();
  void clear_has_projectile_model_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  ::google::protobuf::internal::ArenaStringPtr selected_algorithm_;
  ::google::protobuf::internal::ArenaStringPtr camera_name_;
  ::roborts_detection::CameraGimbalTransform* camera_gimbal_transform_;
  ::roborts_detection::ProjectileModelInfo* projectile_model_info_;
  ::google::protobuf::uint32 undetected_armor_delay_;
  friend struct ::protobuf_armor_5fdetection_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CameraGimbalTransform

// required float offset_x = 1;
inline bool CameraGimbalTransform::has_offset_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraGimbalTransform::clear_has_offset_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraGimbalTransform::clear_offset_x() {
  offset_x_ = 0;
  clear_has_offset_x();
}
inline float CameraGimbalTransform::offset_x() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_x)
  return offset_x_;
}
inline void CameraGimbalTransform::set_offset_x(float value) {
  set_has_offset_x();
  offset_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_x)
}

// required float offset_y = 2;
inline bool CameraGimbalTransform::has_offset_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraGimbalTransform::clear_has_offset_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraGimbalTransform::clear_offset_y() {
  offset_y_ = 0;
  clear_has_offset_y();
}
inline float CameraGimbalTransform::offset_y() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_y)
  return offset_y_;
}
inline void CameraGimbalTransform::set_offset_y(float value) {
  set_has_offset_y();
  offset_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_y)
}

// required float offset_z = 3;
inline bool CameraGimbalTransform::has_offset_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraGimbalTransform::clear_has_offset_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraGimbalTransform::clear_offset_z() {
  offset_z_ = 0;
  clear_has_offset_z();
}
inline float CameraGimbalTransform::offset_z() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_z)
  return offset_z_;
}
inline void CameraGimbalTransform::set_offset_z(float value) {
  set_has_offset_z();
  offset_z_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_z)
}

// required float offset_pitch = 4;
inline bool CameraGimbalTransform::has_offset_pitch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_pitch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraGimbalTransform::clear_has_offset_pitch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraGimbalTransform::clear_offset_pitch() {
  offset_pitch_ = 0;
  clear_has_offset_pitch();
}
inline float CameraGimbalTransform::offset_pitch() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_pitch)
  return offset_pitch_;
}
inline void CameraGimbalTransform::set_offset_pitch(float value) {
  set_has_offset_pitch();
  offset_pitch_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_pitch)
}

// required float offset_yaw = 5;
inline bool CameraGimbalTransform::has_offset_yaw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_yaw() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraGimbalTransform::clear_has_offset_yaw() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraGimbalTransform::clear_offset_yaw() {
  offset_yaw_ = 0;
  clear_has_offset_yaw();
}
inline float CameraGimbalTransform::offset_yaw() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_yaw)
  return offset_yaw_;
}
inline void CameraGimbalTransform::set_offset_yaw(float value) {
  set_has_offset_yaw();
  offset_yaw_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_yaw)
}

// -------------------------------------------------------------------

// ProjectileModelInfo

// optional float init_v = 1;
inline bool ProjectileModelInfo::has_init_v() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjectileModelInfo::set_has_init_v() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjectileModelInfo::clear_has_init_v() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjectileModelInfo::clear_init_v() {
  init_v_ = 0;
  clear_has_init_v();
}
inline float ProjectileModelInfo::init_v() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ProjectileModelInfo.init_v)
  return init_v_;
}
inline void ProjectileModelInfo::set_init_v(float value) {
  set_has_init_v();
  init_v_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.ProjectileModelInfo.init_v)
}

// optional float init_k = 2;
inline bool ProjectileModelInfo::has_init_k() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProjectileModelInfo::set_has_init_k() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProjectileModelInfo::clear_has_init_k() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProjectileModelInfo::clear_init_k() {
  init_k_ = 0;
  clear_has_init_k();
}
inline float ProjectileModelInfo::init_k() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ProjectileModelInfo.init_k)
  return init_k_;
}
inline void ProjectileModelInfo::set_init_k(float value) {
  set_has_init_k();
  init_k_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.ProjectileModelInfo.init_k)
}

// -------------------------------------------------------------------

// ArmorDetectionAlgorithms

// repeated string name = 1;
inline int ArmorDetectionAlgorithms::name_size() const {
  return name_.size();
}
inline void ArmorDetectionAlgorithms::clear_name() {
  name_.Clear();
}
inline const ::std::string& ArmorDetectionAlgorithms::name(int index) const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.name)
  return name_.Get(index);
}
inline ::std::string* ArmorDetectionAlgorithms::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.name)
  return name_.Mutable(index);
}
inline void ArmorDetectionAlgorithms::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:roborts_detection.ArmorDetectionAlgorithms.name)
  name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ArmorDetectionAlgorithms::set_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:roborts_detection.ArmorDetectionAlgorithms.name)
  name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ArmorDetectionAlgorithms::set_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:roborts_detection.ArmorDetectionAlgorithms.name)
}
inline void ArmorDetectionAlgorithms::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:roborts_detection.ArmorDetectionAlgorithms.name)
}
inline ::std::string* ArmorDetectionAlgorithms::add_name() {
  // @@protoc_insertion_point(field_add_mutable:roborts_detection.ArmorDetectionAlgorithms.name)
  return name_.Add();
}
inline void ArmorDetectionAlgorithms::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:roborts_detection.ArmorDetectionAlgorithms.name)
}
#if LANG_CXX11
inline void ArmorDetectionAlgorithms::add_name(::std::string&& value) {
  name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:roborts_detection.ArmorDetectionAlgorithms.name)
}
#endif
inline void ArmorDetectionAlgorithms::add_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:roborts_detection.ArmorDetectionAlgorithms.name)
}
inline void ArmorDetectionAlgorithms::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:roborts_detection.ArmorDetectionAlgorithms.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ArmorDetectionAlgorithms::name() const {
  // @@protoc_insertion_point(field_list:roborts_detection.ArmorDetectionAlgorithms.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ArmorDetectionAlgorithms::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:roborts_detection.ArmorDetectionAlgorithms.name)
  return &name_;
}

// optional string selected_algorithm = 2;
inline bool ArmorDetectionAlgorithms::has_selected_algorithm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_selected_algorithm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArmorDetectionAlgorithms::clear_has_selected_algorithm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArmorDetectionAlgorithms::clear_selected_algorithm() {
  selected_algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_selected_algorithm();
}
inline const ::std::string& ArmorDetectionAlgorithms::selected_algorithm() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
  return selected_algorithm_.GetNoArena();
}
inline void ArmorDetectionAlgorithms::set_selected_algorithm(const ::std::string& value) {
  set_has_selected_algorithm();
  selected_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
}
#if LANG_CXX11
inline void ArmorDetectionAlgorithms::set_selected_algorithm(::std::string&& value) {
  set_has_selected_algorithm();
  selected_algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
}
#endif
inline void ArmorDetectionAlgorithms::set_selected_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_selected_algorithm();
  selected_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
}
inline void ArmorDetectionAlgorithms::set_selected_algorithm(const char* value, size_t size) {
  set_has_selected_algorithm();
  selected_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
}
inline ::std::string* ArmorDetectionAlgorithms::mutable_selected_algorithm() {
  set_has_selected_algorithm();
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
  return selected_algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArmorDetectionAlgorithms::release_selected_algorithm() {
  // @@protoc_insertion_point(field_release:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
  if (!has_selected_algorithm()) {
    return NULL;
  }
  clear_has_selected_algorithm();
  return selected_algorithm_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArmorDetectionAlgorithms::set_allocated_selected_algorithm(::std::string* selected_algorithm) {
  if (selected_algorithm != NULL) {
    set_has_selected_algorithm();
  } else {
    clear_has_selected_algorithm();
  }
  selected_algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), selected_algorithm);
  // @@protoc_insertion_point(field_set_allocated:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
}

// optional uint32 undetected_armor_delay = 3;
inline bool ArmorDetectionAlgorithms::has_undetected_armor_delay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_undetected_armor_delay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArmorDetectionAlgorithms::clear_has_undetected_armor_delay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArmorDetectionAlgorithms::clear_undetected_armor_delay() {
  undetected_armor_delay_ = 0u;
  clear_has_undetected_armor_delay();
}
inline ::google::protobuf::uint32 ArmorDetectionAlgorithms::undetected_armor_delay() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.undetected_armor_delay)
  return undetected_armor_delay_;
}
inline void ArmorDetectionAlgorithms::set_undetected_armor_delay(::google::protobuf::uint32 value) {
  set_has_undetected_armor_delay();
  undetected_armor_delay_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.ArmorDetectionAlgorithms.undetected_armor_delay)
}

// optional string camera_name = 4;
inline bool ArmorDetectionAlgorithms::has_camera_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_camera_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArmorDetectionAlgorithms::clear_has_camera_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArmorDetectionAlgorithms::clear_camera_name() {
  camera_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_name();
}
inline const ::std::string& ArmorDetectionAlgorithms::camera_name() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.camera_name)
  return camera_name_.GetNoArena();
}
inline void ArmorDetectionAlgorithms::set_camera_name(const ::std::string& value) {
  set_has_camera_name();
  camera_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_detection.ArmorDetectionAlgorithms.camera_name)
}
#if LANG_CXX11
inline void ArmorDetectionAlgorithms::set_camera_name(::std::string&& value) {
  set_has_camera_name();
  camera_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:roborts_detection.ArmorDetectionAlgorithms.camera_name)
}
#endif
inline void ArmorDetectionAlgorithms::set_camera_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_name();
  camera_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_detection.ArmorDetectionAlgorithms.camera_name)
}
inline void ArmorDetectionAlgorithms::set_camera_name(const char* value, size_t size) {
  set_has_camera_name();
  camera_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_detection.ArmorDetectionAlgorithms.camera_name)
}
inline ::std::string* ArmorDetectionAlgorithms::mutable_camera_name() {
  set_has_camera_name();
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.camera_name)
  return camera_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArmorDetectionAlgorithms::release_camera_name() {
  // @@protoc_insertion_point(field_release:roborts_detection.ArmorDetectionAlgorithms.camera_name)
  if (!has_camera_name()) {
    return NULL;
  }
  clear_has_camera_name();
  return camera_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArmorDetectionAlgorithms::set_allocated_camera_name(::std::string* camera_name) {
  if (camera_name != NULL) {
    set_has_camera_name();
  } else {
    clear_has_camera_name();
  }
  camera_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_name);
  // @@protoc_insertion_point(field_set_allocated:roborts_detection.ArmorDetectionAlgorithms.camera_name)
}

// required .roborts_detection.CameraGimbalTransform camera_gimbal_transform = 5;
inline bool ArmorDetectionAlgorithms::has_camera_gimbal_transform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_camera_gimbal_transform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArmorDetectionAlgorithms::clear_has_camera_gimbal_transform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArmorDetectionAlgorithms::clear_camera_gimbal_transform() {
  if (camera_gimbal_transform_ != NULL) camera_gimbal_transform_->Clear();
  clear_has_camera_gimbal_transform();
}
inline const ::roborts_detection::CameraGimbalTransform& ArmorDetectionAlgorithms::_internal_camera_gimbal_transform() const {
  return *camera_gimbal_transform_;
}
inline const ::roborts_detection::CameraGimbalTransform& ArmorDetectionAlgorithms::camera_gimbal_transform() const {
  const ::roborts_detection::CameraGimbalTransform* p = camera_gimbal_transform_;
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.camera_gimbal_transform)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_detection::CameraGimbalTransform*>(
      &::roborts_detection::_CameraGimbalTransform_default_instance_);
}
inline ::roborts_detection::CameraGimbalTransform* ArmorDetectionAlgorithms::release_camera_gimbal_transform() {
  // @@protoc_insertion_point(field_release:roborts_detection.ArmorDetectionAlgorithms.camera_gimbal_transform)
  clear_has_camera_gimbal_transform();
  ::roborts_detection::CameraGimbalTransform* temp = camera_gimbal_transform_;
  camera_gimbal_transform_ = NULL;
  return temp;
}
inline ::roborts_detection::CameraGimbalTransform* ArmorDetectionAlgorithms::mutable_camera_gimbal_transform() {
  set_has_camera_gimbal_transform();
  if (camera_gimbal_transform_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_detection::CameraGimbalTransform>(GetArenaNoVirtual());
    camera_gimbal_transform_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.camera_gimbal_transform)
  return camera_gimbal_transform_;
}
inline void ArmorDetectionAlgorithms::set_allocated_camera_gimbal_transform(::roborts_detection::CameraGimbalTransform* camera_gimbal_transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete camera_gimbal_transform_;
  }
  if (camera_gimbal_transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera_gimbal_transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera_gimbal_transform, submessage_arena);
    }
    set_has_camera_gimbal_transform();
  } else {
    clear_has_camera_gimbal_transform();
  }
  camera_gimbal_transform_ = camera_gimbal_transform;
  // @@protoc_insertion_point(field_set_allocated:roborts_detection.ArmorDetectionAlgorithms.camera_gimbal_transform)
}

// optional .roborts_detection.ProjectileModelInfo projectile_model_info = 6;
inline bool ArmorDetectionAlgorithms::has_projectile_model_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_projectile_model_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArmorDetectionAlgorithms::clear_has_projectile_model_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArmorDetectionAlgorithms::clear_projectile_model_info() {
  if (projectile_model_info_ != NULL) projectile_model_info_->Clear();
  clear_has_projectile_model_info();
}
inline const ::roborts_detection::ProjectileModelInfo& ArmorDetectionAlgorithms::_internal_projectile_model_info() const {
  return *projectile_model_info_;
}
inline const ::roborts_detection::ProjectileModelInfo& ArmorDetectionAlgorithms::projectile_model_info() const {
  const ::roborts_detection::ProjectileModelInfo* p = projectile_model_info_;
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.projectile_model_info)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_detection::ProjectileModelInfo*>(
      &::roborts_detection::_ProjectileModelInfo_default_instance_);
}
inline ::roborts_detection::ProjectileModelInfo* ArmorDetectionAlgorithms::release_projectile_model_info() {
  // @@protoc_insertion_point(field_release:roborts_detection.ArmorDetectionAlgorithms.projectile_model_info)
  clear_has_projectile_model_info();
  ::roborts_detection::ProjectileModelInfo* temp = projectile_model_info_;
  projectile_model_info_ = NULL;
  return temp;
}
inline ::roborts_detection::ProjectileModelInfo* ArmorDetectionAlgorithms::mutable_projectile_model_info() {
  set_has_projectile_model_info();
  if (projectile_model_info_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_detection::ProjectileModelInfo>(GetArenaNoVirtual());
    projectile_model_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.projectile_model_info)
  return projectile_model_info_;
}
inline void ArmorDetectionAlgorithms::set_allocated_projectile_model_info(::roborts_detection::ProjectileModelInfo* projectile_model_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete projectile_model_info_;
  }
  if (projectile_model_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      projectile_model_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, projectile_model_info, submessage_arena);
    }
    set_has_projectile_model_info();
  } else {
    clear_has_projectile_model_info();
  }
  projectile_model_info_ = projectile_model_info;
  // @@protoc_insertion_point(field_set_allocated:roborts_detection.ArmorDetectionAlgorithms.projectile_model_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace roborts_detection

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_armor_5fdetection_2eproto

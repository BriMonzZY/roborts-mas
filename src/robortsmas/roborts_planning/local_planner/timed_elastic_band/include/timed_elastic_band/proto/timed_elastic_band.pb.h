// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: timed_elastic_band.proto

#ifndef PROTOBUF_INCLUDED_timed_5felastic_5fband_2eproto
#define PROTOBUF_INCLUDED_timed_5felastic_5fband_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_timed_5felastic_5fband_2eproto 

namespace protobuf_timed_5felastic_5fband_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_timed_5felastic_5fband_2eproto
namespace roborts_local_planner {
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class FootprintModel;
class FootprintModelDefaultTypeInternal;
extern FootprintModelDefaultTypeInternal _FootprintModel_default_instance_;
class FrameID;
class FrameIDDefaultTypeInternal;
extern FrameIDDefaultTypeInternal _FrameID_default_instance_;
class GoalTolerance;
class GoalToleranceDefaultTypeInternal;
extern GoalToleranceDefaultTypeInternal _GoalTolerance_default_instance_;
class HomotopyClassPlanner;
class HomotopyClassPlannerDefaultTypeInternal;
extern HomotopyClassPlannerDefaultTypeInternal _HomotopyClassPlanner_default_instance_;
class Obstacles;
class ObstaclesDefaultTypeInternal;
extern ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
class Optimization;
class OptimizationDefaultTypeInternal;
extern OptimizationDefaultTypeInternal _Optimization_default_instance_;
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Recovery;
class RecoveryDefaultTypeInternal;
extern RecoveryDefaultTypeInternal _Recovery_default_instance_;
class Robot;
class RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
}  // namespace roborts_local_planner
namespace google {
namespace protobuf {
template<> ::roborts_local_planner::Config* Arena::CreateMaybeMessage<::roborts_local_planner::Config>(Arena*);
template<> ::roborts_local_planner::FootprintModel* Arena::CreateMaybeMessage<::roborts_local_planner::FootprintModel>(Arena*);
template<> ::roborts_local_planner::FrameID* Arena::CreateMaybeMessage<::roborts_local_planner::FrameID>(Arena*);
template<> ::roborts_local_planner::GoalTolerance* Arena::CreateMaybeMessage<::roborts_local_planner::GoalTolerance>(Arena*);
template<> ::roborts_local_planner::HomotopyClassPlanner* Arena::CreateMaybeMessage<::roborts_local_planner::HomotopyClassPlanner>(Arena*);
template<> ::roborts_local_planner::Obstacles* Arena::CreateMaybeMessage<::roborts_local_planner::Obstacles>(Arena*);
template<> ::roborts_local_planner::Optimization* Arena::CreateMaybeMessage<::roborts_local_planner::Optimization>(Arena*);
template<> ::roborts_local_planner::Point2D* Arena::CreateMaybeMessage<::roborts_local_planner::Point2D>(Arena*);
template<> ::roborts_local_planner::Recovery* Arena::CreateMaybeMessage<::roborts_local_planner::Recovery>(Arena*);
template<> ::roborts_local_planner::Robot* Arena::CreateMaybeMessage<::roborts_local_planner::Robot>(Arena*);
template<> ::roborts_local_planner::Trajectory* Arena::CreateMaybeMessage<::roborts_local_planner::Trajectory>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace roborts_local_planner {

enum FootprintModel_FootprintType {
  FootprintModel_FootprintType_POINT = 0,
  FootprintModel_FootprintType_CIRCULAR = 1,
  FootprintModel_FootprintType_TWOCIRCLES = 2,
  FootprintModel_FootprintType_LINE = 3,
  FootprintModel_FootprintType_POLYGON = 4
};
bool FootprintModel_FootprintType_IsValid(int value);
const FootprintModel_FootprintType FootprintModel_FootprintType_FootprintType_MIN = FootprintModel_FootprintType_POINT;
const FootprintModel_FootprintType FootprintModel_FootprintType_FootprintType_MAX = FootprintModel_FootprintType_POLYGON;
const int FootprintModel_FootprintType_FootprintType_ARRAYSIZE = FootprintModel_FootprintType_FootprintType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FootprintModel_FootprintType_descriptor();
inline const ::std::string& FootprintModel_FootprintType_Name(FootprintModel_FootprintType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FootprintModel_FootprintType_descriptor(), value);
}
inline bool FootprintModel_FootprintType_Parse(
    const ::std::string& name, FootprintModel_FootprintType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FootprintModel_FootprintType>(
    FootprintModel_FootprintType_descriptor(), name, value);
}
// ===================================================================

class FrameID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.FrameID) */ {
 public:
  FrameID();
  virtual ~FrameID();

  FrameID(const FrameID& from);

  inline FrameID& operator=(const FrameID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrameID(FrameID&& from) noexcept
    : FrameID() {
    *this = ::std::move(from);
  }

  inline FrameID& operator=(FrameID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameID* internal_default_instance() {
    return reinterpret_cast<const FrameID*>(
               &_FrameID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(FrameID* other);
  friend void swap(FrameID& a, FrameID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrameID* New() const final {
    return CreateMaybeMessage<FrameID>(NULL);
  }

  FrameID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FrameID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FrameID& from);
  void MergeFrom(const FrameID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string odom_frame = 1;
  bool has_odom_frame() const;
  void clear_odom_frame();
  static const int kOdomFrameFieldNumber = 1;
  const ::std::string& odom_frame() const;
  void set_odom_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_odom_frame(::std::string&& value);
  #endif
  void set_odom_frame(const char* value);
  void set_odom_frame(const char* value, size_t size);
  ::std::string* mutable_odom_frame();
  ::std::string* release_odom_frame();
  void set_allocated_odom_frame(::std::string* odom_frame);

  // optional string map_frame = 2;
  bool has_map_frame() const;
  void clear_map_frame();
  static const int kMapFrameFieldNumber = 2;
  const ::std::string& map_frame() const;
  void set_map_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_map_frame(::std::string&& value);
  #endif
  void set_map_frame(const char* value);
  void set_map_frame(const char* value, size_t size);
  ::std::string* mutable_map_frame();
  ::std::string* release_map_frame();
  void set_allocated_map_frame(::std::string* map_frame);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.FrameID)
 private:
  void set_has_odom_frame();
  void clear_has_odom_frame();
  void set_has_map_frame();
  void clear_has_map_frame();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr odom_frame_;
  ::google::protobuf::internal::ArenaStringPtr map_frame_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Point2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Point2D) */ {
 public:
  Point2D();
  virtual ~Point2D();

  Point2D(const Point2D& from);

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point2D(Point2D&& from) noexcept
    : Point2D() {
    *this = ::std::move(from);
  }

  inline Point2D& operator=(Point2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point2D* internal_default_instance() {
    return reinterpret_cast<const Point2D*>(
               &_Point2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Point2D* other);
  friend void swap(Point2D& a, Point2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point2D* New() const final {
    return CreateMaybeMessage<Point2D>(NULL);
  }

  Point2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point2D& from);
  void MergeFrom(const Point2D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Point2D)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Trajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Trajectory) */ {
 public:
  Trajectory();
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Trajectory* other);
  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trajectory* New() const final {
    return CreateMaybeMessage<Trajectory>(NULL);
  }

  Trajectory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Trajectory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float dt_ref = 2;
  bool has_dt_ref() const;
  void clear_dt_ref();
  static const int kDtRefFieldNumber = 2;
  float dt_ref() const;
  void set_dt_ref(float value);

  // optional float dt_hysteresis = 3;
  bool has_dt_hysteresis() const;
  void clear_dt_hysteresis();
  static const int kDtHysteresisFieldNumber = 3;
  float dt_hysteresis() const;
  void set_dt_hysteresis(float value);

  // optional bool teb_autosize = 1;
  bool has_teb_autosize() const;
  void clear_teb_autosize();
  static const int kTebAutosizeFieldNumber = 1;
  bool teb_autosize() const;
  void set_teb_autosize(bool value);

  // optional bool global_plan_overwrite_orientation = 4;
  bool has_global_plan_overwrite_orientation() const;
  void clear_global_plan_overwrite_orientation();
  static const int kGlobalPlanOverwriteOrientationFieldNumber = 4;
  bool global_plan_overwrite_orientation() const;
  void set_global_plan_overwrite_orientation(bool value);

  // optional bool allow_init_with_backwards_motion = 5;
  bool has_allow_init_with_backwards_motion() const;
  void clear_allow_init_with_backwards_motion();
  static const int kAllowInitWithBackwardsMotionFieldNumber = 5;
  bool allow_init_with_backwards_motion() const;
  void set_allow_init_with_backwards_motion(bool value);

  // optional bool via_points_ordered = 7;
  bool has_via_points_ordered() const;
  void clear_via_points_ordered();
  static const int kViaPointsOrderedFieldNumber = 7;
  bool via_points_ordered() const;
  void set_via_points_ordered(bool value);

  // optional float global_plan_viapoint_sep = 6;
  bool has_global_plan_viapoint_sep() const;
  void clear_global_plan_viapoint_sep();
  static const int kGlobalPlanViapointSepFieldNumber = 6;
  float global_plan_viapoint_sep() const;
  void set_global_plan_viapoint_sep(float value);

  // optional float max_global_plan_lookahead_dist = 8;
  bool has_max_global_plan_lookahead_dist() const;
  void clear_max_global_plan_lookahead_dist();
  static const int kMaxGlobalPlanLookaheadDistFieldNumber = 8;
  float max_global_plan_lookahead_dist() const;
  void set_max_global_plan_lookahead_dist(float value);

  // optional float force_reinit_new_goal_dist = 10;
  bool has_force_reinit_new_goal_dist() const;
  void clear_force_reinit_new_goal_dist();
  static const int kForceReinitNewGoalDistFieldNumber = 10;
  float force_reinit_new_goal_dist() const;
  void set_force_reinit_new_goal_dist(float value);

  // optional int64 feasibility_check_no_poses = 11;
  bool has_feasibility_check_no_poses() const;
  void clear_feasibility_check_no_poses();
  static const int kFeasibilityCheckNoPosesFieldNumber = 11;
  ::google::protobuf::int64 feasibility_check_no_poses() const;
  void set_feasibility_check_no_poses(::google::protobuf::int64 value);

  // optional int64 min_samples = 13;
  bool has_min_samples() const;
  void clear_min_samples();
  static const int kMinSamplesFieldNumber = 13;
  ::google::protobuf::int64 min_samples() const;
  void set_min_samples(::google::protobuf::int64 value);

  // optional int64 max_samples = 14;
  bool has_max_samples() const;
  void clear_max_samples();
  static const int kMaxSamplesFieldNumber = 14;
  ::google::protobuf::int64 max_samples() const;
  void set_max_samples(::google::protobuf::int64 value);

  // optional bool exact_arc_length = 9;
  bool has_exact_arc_length() const;
  void clear_exact_arc_length();
  static const int kExactArcLengthFieldNumber = 9;
  bool exact_arc_length() const;
  void set_exact_arc_length(bool value);

  // optional bool publish_feedback = 12;
  bool has_publish_feedback() const;
  void clear_publish_feedback();
  static const int kPublishFeedbackFieldNumber = 12;
  bool publish_feedback() const;
  void set_publish_feedback(bool value);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Trajectory)
 private:
  void set_has_teb_autosize();
  void clear_has_teb_autosize();
  void set_has_dt_ref();
  void clear_has_dt_ref();
  void set_has_dt_hysteresis();
  void clear_has_dt_hysteresis();
  void set_has_global_plan_overwrite_orientation();
  void clear_has_global_plan_overwrite_orientation();
  void set_has_allow_init_with_backwards_motion();
  void clear_has_allow_init_with_backwards_motion();
  void set_has_global_plan_viapoint_sep();
  void clear_has_global_plan_viapoint_sep();
  void set_has_via_points_ordered();
  void clear_has_via_points_ordered();
  void set_has_max_global_plan_lookahead_dist();
  void clear_has_max_global_plan_lookahead_dist();
  void set_has_exact_arc_length();
  void clear_has_exact_arc_length();
  void set_has_force_reinit_new_goal_dist();
  void clear_has_force_reinit_new_goal_dist();
  void set_has_feasibility_check_no_poses();
  void clear_has_feasibility_check_no_poses();
  void set_has_publish_feedback();
  void clear_has_publish_feedback();
  void set_has_min_samples();
  void clear_has_min_samples();
  void set_has_max_samples();
  void clear_has_max_samples();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float dt_ref_;
  float dt_hysteresis_;
  bool teb_autosize_;
  bool global_plan_overwrite_orientation_;
  bool allow_init_with_backwards_motion_;
  bool via_points_ordered_;
  float global_plan_viapoint_sep_;
  float max_global_plan_lookahead_dist_;
  float force_reinit_new_goal_dist_;
  ::google::protobuf::int64 feasibility_check_no_poses_;
  ::google::protobuf::int64 min_samples_;
  ::google::protobuf::int64 max_samples_;
  bool exact_arc_length_;
  bool publish_feedback_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FootprintModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.FootprintModel) */ {
 public:
  FootprintModel();
  virtual ~FootprintModel();

  FootprintModel(const FootprintModel& from);

  inline FootprintModel& operator=(const FootprintModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FootprintModel(FootprintModel&& from) noexcept
    : FootprintModel() {
    *this = ::std::move(from);
  }

  inline FootprintModel& operator=(FootprintModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FootprintModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FootprintModel* internal_default_instance() {
    return reinterpret_cast<const FootprintModel*>(
               &_FootprintModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FootprintModel* other);
  friend void swap(FootprintModel& a, FootprintModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FootprintModel* New() const final {
    return CreateMaybeMessage<FootprintModel>(NULL);
  }

  FootprintModel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FootprintModel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FootprintModel& from);
  void MergeFrom(const FootprintModel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FootprintModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FootprintModel_FootprintType FootprintType;
  static const FootprintType POINT =
    FootprintModel_FootprintType_POINT;
  static const FootprintType CIRCULAR =
    FootprintModel_FootprintType_CIRCULAR;
  static const FootprintType TWOCIRCLES =
    FootprintModel_FootprintType_TWOCIRCLES;
  static const FootprintType LINE =
    FootprintModel_FootprintType_LINE;
  static const FootprintType POLYGON =
    FootprintModel_FootprintType_POLYGON;
  static inline bool FootprintType_IsValid(int value) {
    return FootprintModel_FootprintType_IsValid(value);
  }
  static const FootprintType FootprintType_MIN =
    FootprintModel_FootprintType_FootprintType_MIN;
  static const FootprintType FootprintType_MAX =
    FootprintModel_FootprintType_FootprintType_MAX;
  static const int FootprintType_ARRAYSIZE =
    FootprintModel_FootprintType_FootprintType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FootprintType_descriptor() {
    return FootprintModel_FootprintType_descriptor();
  }
  static inline const ::std::string& FootprintType_Name(FootprintType value) {
    return FootprintModel_FootprintType_Name(value);
  }
  static inline bool FootprintType_Parse(const ::std::string& name,
      FootprintType* value) {
    return FootprintModel_FootprintType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .roborts_local_planner.Point2D robot_vertices = 7;
  int robot_vertices_size() const;
  void clear_robot_vertices();
  static const int kRobotVerticesFieldNumber = 7;
  ::roborts_local_planner::Point2D* mutable_robot_vertices(int index);
  ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::Point2D >*
      mutable_robot_vertices();
  const ::roborts_local_planner::Point2D& robot_vertices(int index) const;
  ::roborts_local_planner::Point2D* add_robot_vertices();
  const ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::Point2D >&
      robot_vertices() const;

  // optional double radius = 2;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  double radius() const;
  void set_radius(double value);

  // optional double front_offset = 3;
  bool has_front_offset() const;
  void clear_front_offset();
  static const int kFrontOffsetFieldNumber = 3;
  double front_offset() const;
  void set_front_offset(double value);

  // optional double front_radius = 4;
  bool has_front_radius() const;
  void clear_front_radius();
  static const int kFrontRadiusFieldNumber = 4;
  double front_radius() const;
  void set_front_radius(double value);

  // optional double rear_offset = 5;
  bool has_rear_offset() const;
  void clear_rear_offset();
  static const int kRearOffsetFieldNumber = 5;
  double rear_offset() const;
  void set_rear_offset(double value);

  // optional double rear_radius = 6;
  bool has_rear_radius() const;
  void clear_rear_radius();
  static const int kRearRadiusFieldNumber = 6;
  double rear_radius() const;
  void set_rear_radius(double value);

  // optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::roborts_local_planner::FootprintModel_FootprintType type() const;
  void set_type(::roborts_local_planner::FootprintModel_FootprintType value);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.FootprintModel)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_radius();
  void clear_has_radius();
  void set_has_front_offset();
  void clear_has_front_offset();
  void set_has_front_radius();
  void clear_has_front_radius();
  void set_has_rear_offset();
  void clear_has_rear_offset();
  void set_has_rear_radius();
  void clear_has_rear_radius();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::Point2D > robot_vertices_;
  double radius_;
  double front_offset_;
  double front_radius_;
  double rear_offset_;
  double rear_radius_;
  int type_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Robot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Robot) */ {
 public:
  Robot();
  virtual ~Robot();

  Robot(const Robot& from);

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(Robot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Robot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Robot* other);
  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Robot* New() const final {
    return CreateMaybeMessage<Robot>(NULL);
  }

  Robot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float max_vel_x = 1;
  bool has_max_vel_x() const;
  void clear_max_vel_x();
  static const int kMaxVelXFieldNumber = 1;
  float max_vel_x() const;
  void set_max_vel_x(float value);

  // optional float max_vel_x_backwards = 2;
  bool has_max_vel_x_backwards() const;
  void clear_max_vel_x_backwards();
  static const int kMaxVelXBackwardsFieldNumber = 2;
  float max_vel_x_backwards() const;
  void set_max_vel_x_backwards(float value);

  // optional float max_vel_y = 3;
  bool has_max_vel_y() const;
  void clear_max_vel_y();
  static const int kMaxVelYFieldNumber = 3;
  float max_vel_y() const;
  void set_max_vel_y(float value);

  // optional float max_vel_theta = 4;
  bool has_max_vel_theta() const;
  void clear_max_vel_theta();
  static const int kMaxVelThetaFieldNumber = 4;
  float max_vel_theta() const;
  void set_max_vel_theta(float value);

  // optional float acc_lim_x = 5;
  bool has_acc_lim_x() const;
  void clear_acc_lim_x();
  static const int kAccLimXFieldNumber = 5;
  float acc_lim_x() const;
  void set_acc_lim_x(float value);

  // optional float acc_lim_y = 6;
  bool has_acc_lim_y() const;
  void clear_acc_lim_y();
  static const int kAccLimYFieldNumber = 6;
  float acc_lim_y() const;
  void set_acc_lim_y(float value);

  // optional float acc_lim_theta = 7;
  bool has_acc_lim_theta() const;
  void clear_acc_lim_theta();
  static const int kAccLimThetaFieldNumber = 7;
  float acc_lim_theta() const;
  void set_acc_lim_theta(float value);

  // optional float min_turning_radius = 8;
  bool has_min_turning_radius() const;
  void clear_min_turning_radius();
  static const int kMinTurningRadiusFieldNumber = 8;
  float min_turning_radius() const;
  void set_min_turning_radius(float value);

  // optional float wheelbase = 9;
  bool has_wheelbase() const;
  void clear_wheelbase();
  static const int kWheelbaseFieldNumber = 9;
  float wheelbase() const;
  void set_wheelbase(float value);

  // optional bool cmd_angle_instead_rotvel = 10;
  bool has_cmd_angle_instead_rotvel() const;
  void clear_cmd_angle_instead_rotvel();
  static const int kCmdAngleInsteadRotvelFieldNumber = 10;
  bool cmd_angle_instead_rotvel() const;
  void set_cmd_angle_instead_rotvel(bool value);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Robot)
 private:
  void set_has_max_vel_x();
  void clear_has_max_vel_x();
  void set_has_max_vel_x_backwards();
  void clear_has_max_vel_x_backwards();
  void set_has_max_vel_y();
  void clear_has_max_vel_y();
  void set_has_max_vel_theta();
  void clear_has_max_vel_theta();
  void set_has_acc_lim_x();
  void clear_has_acc_lim_x();
  void set_has_acc_lim_y();
  void clear_has_acc_lim_y();
  void set_has_acc_lim_theta();
  void clear_has_acc_lim_theta();
  void set_has_min_turning_radius();
  void clear_has_min_turning_radius();
  void set_has_wheelbase();
  void clear_has_wheelbase();
  void set_has_cmd_angle_instead_rotvel();
  void clear_has_cmd_angle_instead_rotvel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float max_vel_x_;
  float max_vel_x_backwards_;
  float max_vel_y_;
  float max_vel_theta_;
  float acc_lim_x_;
  float acc_lim_y_;
  float acc_lim_theta_;
  float min_turning_radius_;
  float wheelbase_;
  bool cmd_angle_instead_rotvel_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GoalTolerance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.GoalTolerance) */ {
 public:
  GoalTolerance();
  virtual ~GoalTolerance();

  GoalTolerance(const GoalTolerance& from);

  inline GoalTolerance& operator=(const GoalTolerance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GoalTolerance(GoalTolerance&& from) noexcept
    : GoalTolerance() {
    *this = ::std::move(from);
  }

  inline GoalTolerance& operator=(GoalTolerance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoalTolerance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GoalTolerance* internal_default_instance() {
    return reinterpret_cast<const GoalTolerance*>(
               &_GoalTolerance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GoalTolerance* other);
  friend void swap(GoalTolerance& a, GoalTolerance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GoalTolerance* New() const final {
    return CreateMaybeMessage<GoalTolerance>(NULL);
  }

  GoalTolerance* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GoalTolerance>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GoalTolerance& from);
  void MergeFrom(const GoalTolerance& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoalTolerance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float xy_goal_tolerance = 1;
  bool has_xy_goal_tolerance() const;
  void clear_xy_goal_tolerance();
  static const int kXyGoalToleranceFieldNumber = 1;
  float xy_goal_tolerance() const;
  void set_xy_goal_tolerance(float value);

  // optional float yaw_goal_tolerance = 2;
  bool has_yaw_goal_tolerance() const;
  void clear_yaw_goal_tolerance();
  static const int kYawGoalToleranceFieldNumber = 2;
  float yaw_goal_tolerance() const;
  void set_yaw_goal_tolerance(float value);

  // optional bool free_goal_vel = 3;
  bool has_free_goal_vel() const;
  void clear_free_goal_vel();
  static const int kFreeGoalVelFieldNumber = 3;
  bool free_goal_vel() const;
  void set_free_goal_vel(bool value);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.GoalTolerance)
 private:
  void set_has_xy_goal_tolerance();
  void clear_has_xy_goal_tolerance();
  void set_has_yaw_goal_tolerance();
  void clear_has_yaw_goal_tolerance();
  void set_has_free_goal_vel();
  void clear_has_free_goal_vel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float xy_goal_tolerance_;
  float yaw_goal_tolerance_;
  bool free_goal_vel_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Obstacles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Obstacles) */ {
 public:
  Obstacles();
  virtual ~Obstacles();

  Obstacles(const Obstacles& from);

  inline Obstacles& operator=(const Obstacles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Obstacles(Obstacles&& from) noexcept
    : Obstacles() {
    *this = ::std::move(from);
  }

  inline Obstacles& operator=(Obstacles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Obstacles* internal_default_instance() {
    return reinterpret_cast<const Obstacles*>(
               &_Obstacles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Obstacles* other);
  friend void swap(Obstacles& a, Obstacles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Obstacles* New() const final {
    return CreateMaybeMessage<Obstacles>(NULL);
  }

  Obstacles* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Obstacles>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Obstacles& from);
  void MergeFrom(const Obstacles& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string costmap_converter_plugin = 9;
  bool has_costmap_converter_plugin() const;
  void clear_costmap_converter_plugin();
  static const int kCostmapConverterPluginFieldNumber = 9;
  const ::std::string& costmap_converter_plugin() const;
  void set_costmap_converter_plugin(const ::std::string& value);
  #if LANG_CXX11
  void set_costmap_converter_plugin(::std::string&& value);
  #endif
  void set_costmap_converter_plugin(const char* value);
  void set_costmap_converter_plugin(const char* value, size_t size);
  ::std::string* mutable_costmap_converter_plugin();
  ::std::string* release_costmap_converter_plugin();
  void set_allocated_costmap_converter_plugin(::std::string* costmap_converter_plugin);

  // optional float min_obstacle_dist = 1;
  bool has_min_obstacle_dist() const;
  void clear_min_obstacle_dist();
  static const int kMinObstacleDistFieldNumber = 1;
  float min_obstacle_dist() const;
  void set_min_obstacle_dist(float value);

  // optional float inflation_dist = 2;
  bool has_inflation_dist() const;
  void clear_inflation_dist();
  static const int kInflationDistFieldNumber = 2;
  float inflation_dist() const;
  void set_inflation_dist(float value);

  // optional float costmap_obstacles_behind_robot_dist = 4;
  bool has_costmap_obstacles_behind_robot_dist() const;
  void clear_costmap_obstacles_behind_robot_dist();
  static const int kCostmapObstaclesBehindRobotDistFieldNumber = 4;
  float costmap_obstacles_behind_robot_dist() const;
  void set_costmap_obstacles_behind_robot_dist(float value);

  // optional float obstacle_poses_affected = 5;
  bool has_obstacle_poses_affected() const;
  void clear_obstacle_poses_affected();
  static const int kObstaclePosesAffectedFieldNumber = 5;
  float obstacle_poses_affected() const;
  void set_obstacle_poses_affected(float value);

  // optional bool include_costmap_obstacles = 3;
  bool has_include_costmap_obstacles() const;
  void clear_include_costmap_obstacles();
  static const int kIncludeCostmapObstaclesFieldNumber = 3;
  bool include_costmap_obstacles() const;
  void set_include_costmap_obstacles(bool value);

  // optional bool legacy_obstacle_association = 6;
  bool has_legacy_obstacle_association() const;
  void clear_legacy_obstacle_association();
  static const int kLegacyObstacleAssociationFieldNumber = 6;
  bool legacy_obstacle_association() const;
  void set_legacy_obstacle_association(bool value);

  // optional bool costmap_converter_spin_thread = 10;
  bool has_costmap_converter_spin_thread() const;
  void clear_costmap_converter_spin_thread();
  static const int kCostmapConverterSpinThreadFieldNumber = 10;
  bool costmap_converter_spin_thread() const;
  void set_costmap_converter_spin_thread(bool value);

  // optional float obstacle_association_cutoff_factor = 7;
  bool has_obstacle_association_cutoff_factor() const;
  void clear_obstacle_association_cutoff_factor();
  static const int kObstacleAssociationCutoffFactorFieldNumber = 7;
  float obstacle_association_cutoff_factor() const;
  void set_obstacle_association_cutoff_factor(float value);

  // optional float obstacle_association_force_inclusion_factor = 8;
  bool has_obstacle_association_force_inclusion_factor() const;
  void clear_obstacle_association_force_inclusion_factor();
  static const int kObstacleAssociationForceInclusionFactorFieldNumber = 8;
  float obstacle_association_force_inclusion_factor() const;
  void set_obstacle_association_force_inclusion_factor(float value);

  // optional float costmap_converter_rate = 11;
  bool has_costmap_converter_rate() const;
  void clear_costmap_converter_rate();
  static const int kCostmapConverterRateFieldNumber = 11;
  float costmap_converter_rate() const;
  void set_costmap_converter_rate(float value);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Obstacles)
 private:
  void set_has_min_obstacle_dist();
  void clear_has_min_obstacle_dist();
  void set_has_inflation_dist();
  void clear_has_inflation_dist();
  void set_has_include_costmap_obstacles();
  void clear_has_include_costmap_obstacles();
  void set_has_costmap_obstacles_behind_robot_dist();
  void clear_has_costmap_obstacles_behind_robot_dist();
  void set_has_obstacle_poses_affected();
  void clear_has_obstacle_poses_affected();
  void set_has_legacy_obstacle_association();
  void clear_has_legacy_obstacle_association();
  void set_has_obstacle_association_cutoff_factor();
  void clear_has_obstacle_association_cutoff_factor();
  void set_has_obstacle_association_force_inclusion_factor();
  void clear_has_obstacle_association_force_inclusion_factor();
  void set_has_costmap_converter_plugin();
  void clear_has_costmap_converter_plugin();
  void set_has_costmap_converter_spin_thread();
  void clear_has_costmap_converter_spin_thread();
  void set_has_costmap_converter_rate();
  void clear_has_costmap_converter_rate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr costmap_converter_plugin_;
  float min_obstacle_dist_;
  float inflation_dist_;
  float costmap_obstacles_behind_robot_dist_;
  float obstacle_poses_affected_;
  bool include_costmap_obstacles_;
  bool legacy_obstacle_association_;
  bool costmap_converter_spin_thread_;
  float obstacle_association_cutoff_factor_;
  float obstacle_association_force_inclusion_factor_;
  float costmap_converter_rate_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Optimization : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Optimization) */ {
 public:
  Optimization();
  virtual ~Optimization();

  Optimization(const Optimization& from);

  inline Optimization& operator=(const Optimization& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optimization(Optimization&& from) noexcept
    : Optimization() {
    *this = ::std::move(from);
  }

  inline Optimization& operator=(Optimization&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Optimization& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optimization* internal_default_instance() {
    return reinterpret_cast<const Optimization*>(
               &_Optimization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Optimization* other);
  friend void swap(Optimization& a, Optimization& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optimization* New() const final {
    return CreateMaybeMessage<Optimization>(NULL);
  }

  Optimization* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Optimization>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Optimization& from);
  void MergeFrom(const Optimization& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optimization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 no_inner_iterations = 1;
  bool has_no_inner_iterations() const;
  void clear_no_inner_iterations();
  static const int kNoInnerIterationsFieldNumber = 1;
  ::google::protobuf::int32 no_inner_iterations() const;
  void set_no_inner_iterations(::google::protobuf::int32 value);

  // optional int32 no_outer_iterations = 2;
  bool has_no_outer_iterations() const;
  void clear_no_outer_iterations();
  static const int kNoOuterIterationsFieldNumber = 2;
  ::google::protobuf::int32 no_outer_iterations() const;
  void set_no_outer_iterations(::google::protobuf::int32 value);

  // optional bool optimization_activate = 3;
  bool has_optimization_activate() const;
  void clear_optimization_activate();
  static const int kOptimizationActivateFieldNumber = 3;
  bool optimization_activate() const;
  void set_optimization_activate(bool value);

  // optional bool optimization_verbose = 4;
  bool has_optimization_verbose() const;
  void clear_optimization_verbose();
  static const int kOptimizationVerboseFieldNumber = 4;
  bool optimization_verbose() const;
  void set_optimization_verbose(bool value);

  // optional float penalty_epsilon = 5;
  bool has_penalty_epsilon() const;
  void clear_penalty_epsilon();
  static const int kPenaltyEpsilonFieldNumber = 5;
  float penalty_epsilon() const;
  void set_penalty_epsilon(float value);

  // optional float weight_max_vel_x = 6;
  bool has_weight_max_vel_x() const;
  void clear_weight_max_vel_x();
  static const int kWeightMaxVelXFieldNumber = 6;
  float weight_max_vel_x() const;
  void set_weight_max_vel_x(float value);

  // optional float weight_max_vel_y = 7;
  bool has_weight_max_vel_y() const;
  void clear_weight_max_vel_y();
  static const int kWeightMaxVelYFieldNumber = 7;
  float weight_max_vel_y() const;
  void set_weight_max_vel_y(float value);

  // optional float weight_max_vel_theta = 8;
  bool has_weight_max_vel_theta() const;
  void clear_weight_max_vel_theta();
  static const int kWeightMaxVelThetaFieldNumber = 8;
  float weight_max_vel_theta() const;
  void set_weight_max_vel_theta(float value);

  // optional float weight_acc_lim_x = 9;
  bool has_weight_acc_lim_x() const;
  void clear_weight_acc_lim_x();
  static const int kWeightAccLimXFieldNumber = 9;
  float weight_acc_lim_x() const;
  void set_weight_acc_lim_x(float value);

  // optional float weight_acc_lim_y = 10;
  bool has_weight_acc_lim_y() const;
  void clear_weight_acc_lim_y();
  static const int kWeightAccLimYFieldNumber = 10;
  float weight_acc_lim_y() const;
  void set_weight_acc_lim_y(float value);

  // optional float weight_acc_lim_thet = 11;
  bool has_weight_acc_lim_thet() const;
  void clear_weight_acc_lim_thet();
  static const int kWeightAccLimThetFieldNumber = 11;
  float weight_acc_lim_thet() const;
  void set_weight_acc_lim_thet(float value);

  // optional float weight_kinematics_nh = 12;
  bool has_weight_kinematics_nh() const;
  void clear_weight_kinematics_nh();
  static const int kWeightKinematicsNhFieldNumber = 12;
  float weight_kinematics_nh() const;
  void set_weight_kinematics_nh(float value);

  // optional float weight_kinematics_forward_drive = 13;
  bool has_weight_kinematics_forward_drive() const;
  void clear_weight_kinematics_forward_drive();
  static const int kWeightKinematicsForwardDriveFieldNumber = 13;
  float weight_kinematics_forward_drive() const;
  void set_weight_kinematics_forward_drive(float value);

  // optional float weight_kinematics_turning_radius = 14;
  bool has_weight_kinematics_turning_radius() const;
  void clear_weight_kinematics_turning_radius();
  static const int kWeightKinematicsTurningRadiusFieldNumber = 14;
  float weight_kinematics_turning_radius() const;
  void set_weight_kinematics_turning_radius(float value);

  // optional float weight_optimaltime = 15;
  bool has_weight_optimaltime() const;
  void clear_weight_optimaltime();
  static const int kWeightOptimaltimeFieldNumber = 15;
  float weight_optimaltime() const;
  void set_weight_optimaltime(float value);

  // optional float weight_obstacle = 16;
  bool has_weight_obstacle() const;
  void clear_weight_obstacle();
  static const int kWeightObstacleFieldNumber = 16;
  float weight_obstacle() const;
  void set_weight_obstacle(float value);

  // optional float weight_inflation = 17;
  bool has_weight_inflation() const;
  void clear_weight_inflation();
  static const int kWeightInflationFieldNumber = 17;
  float weight_inflation() const;
  void set_weight_inflation(float value);

  // optional float weight_dynamic_obstacle = 18;
  bool has_weight_dynamic_obstacle() const;
  void clear_weight_dynamic_obstacle();
  static const int kWeightDynamicObstacleFieldNumber = 18;
  float weight_dynamic_obstacle() const;
  void set_weight_dynamic_obstacle(float value);

  // optional float weight_viapoint = 19;
  bool has_weight_viapoint() const;
  void clear_weight_viapoint();
  static const int kWeightViapointFieldNumber = 19;
  float weight_viapoint() const;
  void set_weight_viapoint(float value);

  // optional float weight_adapt_factor = 20;
  bool has_weight_adapt_factor() const;
  void clear_weight_adapt_factor();
  static const int kWeightAdaptFactorFieldNumber = 20;
  float weight_adapt_factor() const;
  void set_weight_adapt_factor(float value);

  // optional float weight_prefer_rotdir = 21;
  bool has_weight_prefer_rotdir() const;
  void clear_weight_prefer_rotdir();
  static const int kWeightPreferRotdirFieldNumber = 21;
  float weight_prefer_rotdir() const;
  void set_weight_prefer_rotdir(float value);

  // optional float weight_acc_lim_theta = 22;
  bool has_weight_acc_lim_theta() const;
  void clear_weight_acc_lim_theta();
  static const int kWeightAccLimThetaFieldNumber = 22;
  float weight_acc_lim_theta() const;
  void set_weight_acc_lim_theta(float value);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Optimization)
 private:
  void set_has_no_inner_iterations();
  void clear_has_no_inner_iterations();
  void set_has_no_outer_iterations();
  void clear_has_no_outer_iterations();
  void set_has_optimization_activate();
  void clear_has_optimization_activate();
  void set_has_optimization_verbose();
  void clear_has_optimization_verbose();
  void set_has_penalty_epsilon();
  void clear_has_penalty_epsilon();
  void set_has_weight_max_vel_x();
  void clear_has_weight_max_vel_x();
  void set_has_weight_max_vel_y();
  void clear_has_weight_max_vel_y();
  void set_has_weight_max_vel_theta();
  void clear_has_weight_max_vel_theta();
  void set_has_weight_acc_lim_x();
  void clear_has_weight_acc_lim_x();
  void set_has_weight_acc_lim_y();
  void clear_has_weight_acc_lim_y();
  void set_has_weight_acc_lim_thet();
  void clear_has_weight_acc_lim_thet();
  void set_has_weight_kinematics_nh();
  void clear_has_weight_kinematics_nh();
  void set_has_weight_kinematics_forward_drive();
  void clear_has_weight_kinematics_forward_drive();
  void set_has_weight_kinematics_turning_radius();
  void clear_has_weight_kinematics_turning_radius();
  void set_has_weight_optimaltime();
  void clear_has_weight_optimaltime();
  void set_has_weight_obstacle();
  void clear_has_weight_obstacle();
  void set_has_weight_inflation();
  void clear_has_weight_inflation();
  void set_has_weight_dynamic_obstacle();
  void clear_has_weight_dynamic_obstacle();
  void set_has_weight_viapoint();
  void clear_has_weight_viapoint();
  void set_has_weight_adapt_factor();
  void clear_has_weight_adapt_factor();
  void set_has_weight_prefer_rotdir();
  void clear_has_weight_prefer_rotdir();
  void set_has_weight_acc_lim_theta();
  void clear_has_weight_acc_lim_theta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 no_inner_iterations_;
  ::google::protobuf::int32 no_outer_iterations_;
  bool optimization_activate_;
  bool optimization_verbose_;
  float penalty_epsilon_;
  float weight_max_vel_x_;
  float weight_max_vel_y_;
  float weight_max_vel_theta_;
  float weight_acc_lim_x_;
  float weight_acc_lim_y_;
  float weight_acc_lim_thet_;
  float weight_kinematics_nh_;
  float weight_kinematics_forward_drive_;
  float weight_kinematics_turning_radius_;
  float weight_optimaltime_;
  float weight_obstacle_;
  float weight_inflation_;
  float weight_dynamic_obstacle_;
  float weight_viapoint_;
  float weight_adapt_factor_;
  float weight_prefer_rotdir_;
  float weight_acc_lim_theta_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HomotopyClassPlanner : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.HomotopyClassPlanner) */ {
 public:
  HomotopyClassPlanner();
  virtual ~HomotopyClassPlanner();

  HomotopyClassPlanner(const HomotopyClassPlanner& from);

  inline HomotopyClassPlanner& operator=(const HomotopyClassPlanner& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HomotopyClassPlanner(HomotopyClassPlanner&& from) noexcept
    : HomotopyClassPlanner() {
    *this = ::std::move(from);
  }

  inline HomotopyClassPlanner& operator=(HomotopyClassPlanner&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HomotopyClassPlanner& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HomotopyClassPlanner* internal_default_instance() {
    return reinterpret_cast<const HomotopyClassPlanner*>(
               &_HomotopyClassPlanner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(HomotopyClassPlanner* other);
  friend void swap(HomotopyClassPlanner& a, HomotopyClassPlanner& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HomotopyClassPlanner* New() const final {
    return CreateMaybeMessage<HomotopyClassPlanner>(NULL);
  }

  HomotopyClassPlanner* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HomotopyClassPlanner>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HomotopyClassPlanner& from);
  void MergeFrom(const HomotopyClassPlanner& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HomotopyClassPlanner* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_homotopy_class_planning = 1;
  bool has_enable_homotopy_class_planning() const;
  void clear_enable_homotopy_class_planning();
  static const int kEnableHomotopyClassPlanningFieldNumber = 1;
  bool enable_homotopy_class_planning() const;
  void set_enable_homotopy_class_planning(bool value);

  // optional bool enable_multithreading = 2;
  bool has_enable_multithreading() const;
  void clear_enable_multithreading();
  static const int kEnableMultithreadingFieldNumber = 2;
  bool enable_multithreading() const;
  void set_enable_multithreading(bool value);

  // optional bool simple_exploration = 3;
  bool has_simple_exploration() const;
  void clear_simple_exploration();
  static const int kSimpleExplorationFieldNumber = 3;
  bool simple_exploration() const;
  void set_simple_exploration(bool value);

  // optional bool selection_alternative_time_cost = 9;
  bool has_selection_alternative_time_cost() const;
  void clear_selection_alternative_time_cost();
  static const int kSelectionAlternativeTimeCostFieldNumber = 9;
  bool selection_alternative_time_cost() const;
  void set_selection_alternative_time_cost(bool value);

  // optional int32 max_number_classes = 4;
  bool has_max_number_classes() const;
  void clear_max_number_classes();
  static const int kMaxNumberClassesFieldNumber = 4;
  ::google::protobuf::int32 max_number_classes() const;
  void set_max_number_classes(::google::protobuf::int32 value);

  // optional float selection_obst_cost_scale = 5;
  bool has_selection_obst_cost_scale() const;
  void clear_selection_obst_cost_scale();
  static const int kSelectionObstCostScaleFieldNumber = 5;
  float selection_obst_cost_scale() const;
  void set_selection_obst_cost_scale(float value);

  // optional float selection_prefer_initial_plan = 6;
  bool has_selection_prefer_initial_plan() const;
  void clear_selection_prefer_initial_plan();
  static const int kSelectionPreferInitialPlanFieldNumber = 6;
  float selection_prefer_initial_plan() const;
  void set_selection_prefer_initial_plan(float value);

  // optional float selection_viapoint_cost_scale = 7;
  bool has_selection_viapoint_cost_scale() const;
  void clear_selection_viapoint_cost_scale();
  static const int kSelectionViapointCostScaleFieldNumber = 7;
  float selection_viapoint_cost_scale() const;
  void set_selection_viapoint_cost_scale(float value);

  // optional float selection_cost_hysteresis = 8;
  bool has_selection_cost_hysteresis() const;
  void clear_selection_cost_hysteresis();
  static const int kSelectionCostHysteresisFieldNumber = 8;
  float selection_cost_hysteresis() const;
  void set_selection_cost_hysteresis(float value);

  // optional int32 roadmap_graph_no_samples = 10;
  bool has_roadmap_graph_no_samples() const;
  void clear_roadmap_graph_no_samples();
  static const int kRoadmapGraphNoSamplesFieldNumber = 10;
  ::google::protobuf::int32 roadmap_graph_no_samples() const;
  void set_roadmap_graph_no_samples(::google::protobuf::int32 value);

  // optional int32 roadmap_graph_area_width = 11;
  bool has_roadmap_graph_area_width() const;
  void clear_roadmap_graph_area_width();
  static const int kRoadmapGraphAreaWidthFieldNumber = 11;
  ::google::protobuf::int32 roadmap_graph_area_width() const;
  void set_roadmap_graph_area_width(::google::protobuf::int32 value);

  // optional float roadmap_graph_area_length_scale = 12;
  bool has_roadmap_graph_area_length_scale() const;
  void clear_roadmap_graph_area_length_scale();
  static const int kRoadmapGraphAreaLengthScaleFieldNumber = 12;
  float roadmap_graph_area_length_scale() const;
  void set_roadmap_graph_area_length_scale(float value);

  // optional float h_signature_prescaler = 13;
  bool has_h_signature_prescaler() const;
  void clear_h_signature_prescaler();
  static const int kHSignaturePrescalerFieldNumber = 13;
  float h_signature_prescaler() const;
  void set_h_signature_prescaler(float value);

  // optional float h_signature_threshold = 14;
  bool has_h_signature_threshold() const;
  void clear_h_signature_threshold();
  static const int kHSignatureThresholdFieldNumber = 14;
  float h_signature_threshold() const;
  void set_h_signature_threshold(float value);

  // optional float obstacle_keypoint_offset = 15;
  bool has_obstacle_keypoint_offset() const;
  void clear_obstacle_keypoint_offset();
  static const int kObstacleKeypointOffsetFieldNumber = 15;
  float obstacle_keypoint_offset() const;
  void set_obstacle_keypoint_offset(float value);

  // optional float obstacle_heading_threshold = 16;
  bool has_obstacle_heading_threshold() const;
  void clear_obstacle_heading_threshold();
  static const int kObstacleHeadingThresholdFieldNumber = 16;
  float obstacle_heading_threshold() const;
  void set_obstacle_heading_threshold(float value);

  // optional bool viapoints_all_candidates = 17;
  bool has_viapoints_all_candidates() const;
  void clear_viapoints_all_candidates();
  static const int kViapointsAllCandidatesFieldNumber = 17;
  bool viapoints_all_candidates() const;
  void set_viapoints_all_candidates(bool value);

  // optional bool visualize_hc_graph = 18;
  bool has_visualize_hc_graph() const;
  void clear_visualize_hc_graph();
  static const int kVisualizeHcGraphFieldNumber = 18;
  bool visualize_hc_graph() const;
  void set_visualize_hc_graph(bool value);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.HomotopyClassPlanner)
 private:
  void set_has_enable_homotopy_class_planning();
  void clear_has_enable_homotopy_class_planning();
  void set_has_enable_multithreading();
  void clear_has_enable_multithreading();
  void set_has_simple_exploration();
  void clear_has_simple_exploration();
  void set_has_max_number_classes();
  void clear_has_max_number_classes();
  void set_has_selection_obst_cost_scale();
  void clear_has_selection_obst_cost_scale();
  void set_has_selection_prefer_initial_plan();
  void clear_has_selection_prefer_initial_plan();
  void set_has_selection_viapoint_cost_scale();
  void clear_has_selection_viapoint_cost_scale();
  void set_has_selection_cost_hysteresis();
  void clear_has_selection_cost_hysteresis();
  void set_has_selection_alternative_time_cost();
  void clear_has_selection_alternative_time_cost();
  void set_has_roadmap_graph_no_samples();
  void clear_has_roadmap_graph_no_samples();
  void set_has_roadmap_graph_area_width();
  void clear_has_roadmap_graph_area_width();
  void set_has_roadmap_graph_area_length_scale();
  void clear_has_roadmap_graph_area_length_scale();
  void set_has_h_signature_prescaler();
  void clear_has_h_signature_prescaler();
  void set_has_h_signature_threshold();
  void clear_has_h_signature_threshold();
  void set_has_obstacle_keypoint_offset();
  void clear_has_obstacle_keypoint_offset();
  void set_has_obstacle_heading_threshold();
  void clear_has_obstacle_heading_threshold();
  void set_has_viapoints_all_candidates();
  void clear_has_viapoints_all_candidates();
  void set_has_visualize_hc_graph();
  void clear_has_visualize_hc_graph();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool enable_homotopy_class_planning_;
  bool enable_multithreading_;
  bool simple_exploration_;
  bool selection_alternative_time_cost_;
  ::google::protobuf::int32 max_number_classes_;
  float selection_obst_cost_scale_;
  float selection_prefer_initial_plan_;
  float selection_viapoint_cost_scale_;
  float selection_cost_hysteresis_;
  ::google::protobuf::int32 roadmap_graph_no_samples_;
  ::google::protobuf::int32 roadmap_graph_area_width_;
  float roadmap_graph_area_length_scale_;
  float h_signature_prescaler_;
  float h_signature_threshold_;
  float obstacle_keypoint_offset_;
  float obstacle_heading_threshold_;
  bool viapoints_all_candidates_;
  bool visualize_hc_graph_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Recovery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Recovery) */ {
 public:
  Recovery();
  virtual ~Recovery();

  Recovery(const Recovery& from);

  inline Recovery& operator=(const Recovery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Recovery(Recovery&& from) noexcept
    : Recovery() {
    *this = ::std::move(from);
  }

  inline Recovery& operator=(Recovery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Recovery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Recovery* internal_default_instance() {
    return reinterpret_cast<const Recovery*>(
               &_Recovery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Recovery* other);
  friend void swap(Recovery& a, Recovery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Recovery* New() const final {
    return CreateMaybeMessage<Recovery>(NULL);
  }

  Recovery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Recovery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Recovery& from);
  void MergeFrom(const Recovery& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Recovery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double oscillation_v_eps = 4;
  bool has_oscillation_v_eps() const;
  void clear_oscillation_v_eps();
  static const int kOscillationVEpsFieldNumber = 4;
  double oscillation_v_eps() const;
  void set_oscillation_v_eps(double value);

  // optional double oscillation_omega_eps = 5;
  bool has_oscillation_omega_eps() const;
  void clear_oscillation_omega_eps();
  static const int kOscillationOmegaEpsFieldNumber = 5;
  double oscillation_omega_eps() const;
  void set_oscillation_omega_eps(double value);

  // optional double oscillation_recovery_min_duration = 6;
  bool has_oscillation_recovery_min_duration() const;
  void clear_oscillation_recovery_min_duration();
  static const int kOscillationRecoveryMinDurationFieldNumber = 6;
  double oscillation_recovery_min_duration() const;
  void set_oscillation_recovery_min_duration(double value);

  // optional double oscillation_filter_duration = 7;
  bool has_oscillation_filter_duration() const;
  void clear_oscillation_filter_duration();
  static const int kOscillationFilterDurationFieldNumber = 7;
  double oscillation_filter_duration() const;
  void set_oscillation_filter_duration(double value);

  // optional bool shrink_horizon_min_duration = 1;
  bool has_shrink_horizon_min_duration() const;
  void clear_shrink_horizon_min_duration();
  static const int kShrinkHorizonMinDurationFieldNumber = 1;
  bool shrink_horizon_min_duration() const;
  void set_shrink_horizon_min_duration(bool value);

  // optional bool oscillation_recovery = 2;
  bool has_oscillation_recovery() const;
  void clear_oscillation_recovery();
  static const int kOscillationRecoveryFieldNumber = 2;
  bool oscillation_recovery() const;
  void set_oscillation_recovery(bool value);

  // optional bool shrink_horizon_backup = 3;
  bool has_shrink_horizon_backup() const;
  void clear_shrink_horizon_backup();
  static const int kShrinkHorizonBackupFieldNumber = 3;
  bool shrink_horizon_backup() const;
  void set_shrink_horizon_backup(bool value);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Recovery)
 private:
  void set_has_shrink_horizon_min_duration();
  void clear_has_shrink_horizon_min_duration();
  void set_has_oscillation_recovery();
  void clear_has_oscillation_recovery();
  void set_has_shrink_horizon_backup();
  void clear_has_shrink_horizon_backup();
  void set_has_oscillation_v_eps();
  void clear_has_oscillation_v_eps();
  void set_has_oscillation_omega_eps();
  void clear_has_oscillation_omega_eps();
  void set_has_oscillation_recovery_min_duration();
  void clear_has_oscillation_recovery_min_duration();
  void set_has_oscillation_filter_duration();
  void clear_has_oscillation_filter_duration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double oscillation_v_eps_;
  double oscillation_omega_eps_;
  double oscillation_recovery_min_duration_;
  double oscillation_filter_duration_;
  bool shrink_horizon_min_duration_;
  bool oscillation_recovery_;
  bool shrink_horizon_backup_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roborts_local_planner.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(NULL);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .roborts_local_planner.FootprintModel robot_type = 8;
  int robot_type_size() const;
  void clear_robot_type();
  static const int kRobotTypeFieldNumber = 8;
  ::roborts_local_planner::FootprintModel* mutable_robot_type(int index);
  ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::FootprintModel >*
      mutable_robot_type();
  const ::roborts_local_planner::FootprintModel& robot_type(int index) const;
  ::roborts_local_planner::FootprintModel* add_robot_type();
  const ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::FootprintModel >&
      robot_type() const;

  // optional .roborts_local_planner.FrameID opt_frame = 1;
  bool has_opt_frame() const;
  void clear_opt_frame();
  static const int kOptFrameFieldNumber = 1;
  private:
  const ::roborts_local_planner::FrameID& _internal_opt_frame() const;
  public:
  const ::roborts_local_planner::FrameID& opt_frame() const;
  ::roborts_local_planner::FrameID* release_opt_frame();
  ::roborts_local_planner::FrameID* mutable_opt_frame();
  void set_allocated_opt_frame(::roborts_local_planner::FrameID* opt_frame);

  // optional .roborts_local_planner.Trajectory trajectory_opt = 2;
  bool has_trajectory_opt() const;
  void clear_trajectory_opt();
  static const int kTrajectoryOptFieldNumber = 2;
  private:
  const ::roborts_local_planner::Trajectory& _internal_trajectory_opt() const;
  public:
  const ::roborts_local_planner::Trajectory& trajectory_opt() const;
  ::roborts_local_planner::Trajectory* release_trajectory_opt();
  ::roborts_local_planner::Trajectory* mutable_trajectory_opt();
  void set_allocated_trajectory_opt(::roborts_local_planner::Trajectory* trajectory_opt);

  // optional .roborts_local_planner.Robot kinematics_opt = 3;
  bool has_kinematics_opt() const;
  void clear_kinematics_opt();
  static const int kKinematicsOptFieldNumber = 3;
  private:
  const ::roborts_local_planner::Robot& _internal_kinematics_opt() const;
  public:
  const ::roborts_local_planner::Robot& kinematics_opt() const;
  ::roborts_local_planner::Robot* release_kinematics_opt();
  ::roborts_local_planner::Robot* mutable_kinematics_opt();
  void set_allocated_kinematics_opt(::roborts_local_planner::Robot* kinematics_opt);

  // optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
  bool has_tolerance_opt() const;
  void clear_tolerance_opt();
  static const int kToleranceOptFieldNumber = 4;
  private:
  const ::roborts_local_planner::GoalTolerance& _internal_tolerance_opt() const;
  public:
  const ::roborts_local_planner::GoalTolerance& tolerance_opt() const;
  ::roborts_local_planner::GoalTolerance* release_tolerance_opt();
  ::roborts_local_planner::GoalTolerance* mutable_tolerance_opt();
  void set_allocated_tolerance_opt(::roborts_local_planner::GoalTolerance* tolerance_opt);

  // optional .roborts_local_planner.Obstacles obstacles_opt = 5;
  bool has_obstacles_opt() const;
  void clear_obstacles_opt();
  static const int kObstaclesOptFieldNumber = 5;
  private:
  const ::roborts_local_planner::Obstacles& _internal_obstacles_opt() const;
  public:
  const ::roborts_local_planner::Obstacles& obstacles_opt() const;
  ::roborts_local_planner::Obstacles* release_obstacles_opt();
  ::roborts_local_planner::Obstacles* mutable_obstacles_opt();
  void set_allocated_obstacles_opt(::roborts_local_planner::Obstacles* obstacles_opt);

  // optional .roborts_local_planner.Optimization optimize_info = 6;
  bool has_optimize_info() const;
  void clear_optimize_info();
  static const int kOptimizeInfoFieldNumber = 6;
  private:
  const ::roborts_local_planner::Optimization& _internal_optimize_info() const;
  public:
  const ::roborts_local_planner::Optimization& optimize_info() const;
  ::roborts_local_planner::Optimization* release_optimize_info();
  ::roborts_local_planner::Optimization* mutable_optimize_info();
  void set_allocated_optimize_info(::roborts_local_planner::Optimization* optimize_info);

  // optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
  bool has_hcp_opt() const;
  void clear_hcp_opt();
  static const int kHcpOptFieldNumber = 7;
  private:
  const ::roborts_local_planner::HomotopyClassPlanner& _internal_hcp_opt() const;
  public:
  const ::roborts_local_planner::HomotopyClassPlanner& hcp_opt() const;
  ::roborts_local_planner::HomotopyClassPlanner* release_hcp_opt();
  ::roborts_local_planner::HomotopyClassPlanner* mutable_hcp_opt();
  void set_allocated_hcp_opt(::roborts_local_planner::HomotopyClassPlanner* hcp_opt);

  // optional .roborts_local_planner.Recovery recovery_info = 9;
  bool has_recovery_info() const;
  void clear_recovery_info();
  static const int kRecoveryInfoFieldNumber = 9;
  private:
  const ::roborts_local_planner::Recovery& _internal_recovery_info() const;
  public:
  const ::roborts_local_planner::Recovery& recovery_info() const;
  ::roborts_local_planner::Recovery* release_recovery_info();
  ::roborts_local_planner::Recovery* mutable_recovery_info();
  void set_allocated_recovery_info(::roborts_local_planner::Recovery* recovery_info);

  // @@protoc_insertion_point(class_scope:roborts_local_planner.Config)
 private:
  void set_has_opt_frame();
  void clear_has_opt_frame();
  void set_has_trajectory_opt();
  void clear_has_trajectory_opt();
  void set_has_kinematics_opt();
  void clear_has_kinematics_opt();
  void set_has_tolerance_opt();
  void clear_has_tolerance_opt();
  void set_has_obstacles_opt();
  void clear_has_obstacles_opt();
  void set_has_optimize_info();
  void clear_has_optimize_info();
  void set_has_hcp_opt();
  void clear_has_hcp_opt();
  void set_has_recovery_info();
  void clear_has_recovery_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::FootprintModel > robot_type_;
  ::roborts_local_planner::FrameID* opt_frame_;
  ::roborts_local_planner::Trajectory* trajectory_opt_;
  ::roborts_local_planner::Robot* kinematics_opt_;
  ::roborts_local_planner::GoalTolerance* tolerance_opt_;
  ::roborts_local_planner::Obstacles* obstacles_opt_;
  ::roborts_local_planner::Optimization* optimize_info_;
  ::roborts_local_planner::HomotopyClassPlanner* hcp_opt_;
  ::roborts_local_planner::Recovery* recovery_info_;
  friend struct ::protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FrameID

// optional string odom_frame = 1;
inline bool FrameID::has_odom_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameID::set_has_odom_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameID::clear_has_odom_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameID::clear_odom_frame() {
  odom_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_odom_frame();
}
inline const ::std::string& FrameID::odom_frame() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FrameID.odom_frame)
  return odom_frame_.GetNoArena();
}
inline void FrameID::set_odom_frame(const ::std::string& value) {
  set_has_odom_frame();
  odom_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FrameID.odom_frame)
}
#if LANG_CXX11
inline void FrameID::set_odom_frame(::std::string&& value) {
  set_has_odom_frame();
  odom_frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:roborts_local_planner.FrameID.odom_frame)
}
#endif
inline void FrameID::set_odom_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_odom_frame();
  odom_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_local_planner.FrameID.odom_frame)
}
inline void FrameID::set_odom_frame(const char* value, size_t size) {
  set_has_odom_frame();
  odom_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_local_planner.FrameID.odom_frame)
}
inline ::std::string* FrameID::mutable_odom_frame() {
  set_has_odom_frame();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.FrameID.odom_frame)
  return odom_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FrameID::release_odom_frame() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.FrameID.odom_frame)
  if (!has_odom_frame()) {
    return NULL;
  }
  clear_has_odom_frame();
  return odom_frame_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FrameID::set_allocated_odom_frame(::std::string* odom_frame) {
  if (odom_frame != NULL) {
    set_has_odom_frame();
  } else {
    clear_has_odom_frame();
  }
  odom_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), odom_frame);
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.FrameID.odom_frame)
}

// optional string map_frame = 2;
inline bool FrameID::has_map_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameID::set_has_map_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameID::clear_has_map_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameID::clear_map_frame() {
  map_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_frame();
}
inline const ::std::string& FrameID::map_frame() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FrameID.map_frame)
  return map_frame_.GetNoArena();
}
inline void FrameID::set_map_frame(const ::std::string& value) {
  set_has_map_frame();
  map_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.FrameID.map_frame)
}
#if LANG_CXX11
inline void FrameID::set_map_frame(::std::string&& value) {
  set_has_map_frame();
  map_frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:roborts_local_planner.FrameID.map_frame)
}
#endif
inline void FrameID::set_map_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_frame();
  map_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_local_planner.FrameID.map_frame)
}
inline void FrameID::set_map_frame(const char* value, size_t size) {
  set_has_map_frame();
  map_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_local_planner.FrameID.map_frame)
}
inline ::std::string* FrameID::mutable_map_frame() {
  set_has_map_frame();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.FrameID.map_frame)
  return map_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FrameID::release_map_frame() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.FrameID.map_frame)
  if (!has_map_frame()) {
    return NULL;
  }
  clear_has_map_frame();
  return map_frame_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FrameID::set_allocated_map_frame(::std::string* map_frame) {
  if (map_frame != NULL) {
    set_has_map_frame();
  } else {
    clear_has_map_frame();
  }
  map_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_frame);
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.FrameID.map_frame)
}

// -------------------------------------------------------------------

// Point2D

// optional float x = 1;
inline bool Point2D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point2D::x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Point2D.x)
  return x_;
}
inline void Point2D::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Point2D.x)
}

// optional float y = 2;
inline bool Point2D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point2D::y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Point2D.y)
  return y_;
}
inline void Point2D::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Point2D.y)
}

// -------------------------------------------------------------------

// Trajectory

// optional bool teb_autosize = 1;
inline bool Trajectory::has_teb_autosize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trajectory::set_has_teb_autosize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trajectory::clear_has_teb_autosize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trajectory::clear_teb_autosize() {
  teb_autosize_ = false;
  clear_has_teb_autosize();
}
inline bool Trajectory::teb_autosize() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.teb_autosize)
  return teb_autosize_;
}
inline void Trajectory::set_teb_autosize(bool value) {
  set_has_teb_autosize();
  teb_autosize_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.teb_autosize)
}

// optional float dt_ref = 2;
inline bool Trajectory::has_dt_ref() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trajectory::set_has_dt_ref() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trajectory::clear_has_dt_ref() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trajectory::clear_dt_ref() {
  dt_ref_ = 0;
  clear_has_dt_ref();
}
inline float Trajectory::dt_ref() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.dt_ref)
  return dt_ref_;
}
inline void Trajectory::set_dt_ref(float value) {
  set_has_dt_ref();
  dt_ref_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.dt_ref)
}

// optional float dt_hysteresis = 3;
inline bool Trajectory::has_dt_hysteresis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trajectory::set_has_dt_hysteresis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trajectory::clear_has_dt_hysteresis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trajectory::clear_dt_hysteresis() {
  dt_hysteresis_ = 0;
  clear_has_dt_hysteresis();
}
inline float Trajectory::dt_hysteresis() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.dt_hysteresis)
  return dt_hysteresis_;
}
inline void Trajectory::set_dt_hysteresis(float value) {
  set_has_dt_hysteresis();
  dt_hysteresis_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.dt_hysteresis)
}

// optional bool global_plan_overwrite_orientation = 4;
inline bool Trajectory::has_global_plan_overwrite_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Trajectory::set_has_global_plan_overwrite_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Trajectory::clear_has_global_plan_overwrite_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Trajectory::clear_global_plan_overwrite_orientation() {
  global_plan_overwrite_orientation_ = false;
  clear_has_global_plan_overwrite_orientation();
}
inline bool Trajectory::global_plan_overwrite_orientation() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.global_plan_overwrite_orientation)
  return global_plan_overwrite_orientation_;
}
inline void Trajectory::set_global_plan_overwrite_orientation(bool value) {
  set_has_global_plan_overwrite_orientation();
  global_plan_overwrite_orientation_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.global_plan_overwrite_orientation)
}

// optional bool allow_init_with_backwards_motion = 5;
inline bool Trajectory::has_allow_init_with_backwards_motion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Trajectory::set_has_allow_init_with_backwards_motion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Trajectory::clear_has_allow_init_with_backwards_motion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Trajectory::clear_allow_init_with_backwards_motion() {
  allow_init_with_backwards_motion_ = false;
  clear_has_allow_init_with_backwards_motion();
}
inline bool Trajectory::allow_init_with_backwards_motion() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.allow_init_with_backwards_motion)
  return allow_init_with_backwards_motion_;
}
inline void Trajectory::set_allow_init_with_backwards_motion(bool value) {
  set_has_allow_init_with_backwards_motion();
  allow_init_with_backwards_motion_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.allow_init_with_backwards_motion)
}

// optional float global_plan_viapoint_sep = 6;
inline bool Trajectory::has_global_plan_viapoint_sep() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Trajectory::set_has_global_plan_viapoint_sep() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Trajectory::clear_has_global_plan_viapoint_sep() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Trajectory::clear_global_plan_viapoint_sep() {
  global_plan_viapoint_sep_ = 0;
  clear_has_global_plan_viapoint_sep();
}
inline float Trajectory::global_plan_viapoint_sep() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.global_plan_viapoint_sep)
  return global_plan_viapoint_sep_;
}
inline void Trajectory::set_global_plan_viapoint_sep(float value) {
  set_has_global_plan_viapoint_sep();
  global_plan_viapoint_sep_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.global_plan_viapoint_sep)
}

// optional bool via_points_ordered = 7;
inline bool Trajectory::has_via_points_ordered() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Trajectory::set_has_via_points_ordered() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Trajectory::clear_has_via_points_ordered() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Trajectory::clear_via_points_ordered() {
  via_points_ordered_ = false;
  clear_has_via_points_ordered();
}
inline bool Trajectory::via_points_ordered() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.via_points_ordered)
  return via_points_ordered_;
}
inline void Trajectory::set_via_points_ordered(bool value) {
  set_has_via_points_ordered();
  via_points_ordered_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.via_points_ordered)
}

// optional float max_global_plan_lookahead_dist = 8;
inline bool Trajectory::has_max_global_plan_lookahead_dist() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Trajectory::set_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Trajectory::clear_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Trajectory::clear_max_global_plan_lookahead_dist() {
  max_global_plan_lookahead_dist_ = 0;
  clear_has_max_global_plan_lookahead_dist();
}
inline float Trajectory::max_global_plan_lookahead_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.max_global_plan_lookahead_dist)
  return max_global_plan_lookahead_dist_;
}
inline void Trajectory::set_max_global_plan_lookahead_dist(float value) {
  set_has_max_global_plan_lookahead_dist();
  max_global_plan_lookahead_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.max_global_plan_lookahead_dist)
}

// optional bool exact_arc_length = 9;
inline bool Trajectory::has_exact_arc_length() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Trajectory::set_has_exact_arc_length() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Trajectory::clear_has_exact_arc_length() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Trajectory::clear_exact_arc_length() {
  exact_arc_length_ = false;
  clear_has_exact_arc_length();
}
inline bool Trajectory::exact_arc_length() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.exact_arc_length)
  return exact_arc_length_;
}
inline void Trajectory::set_exact_arc_length(bool value) {
  set_has_exact_arc_length();
  exact_arc_length_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.exact_arc_length)
}

// optional float force_reinit_new_goal_dist = 10;
inline bool Trajectory::has_force_reinit_new_goal_dist() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Trajectory::set_has_force_reinit_new_goal_dist() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Trajectory::clear_has_force_reinit_new_goal_dist() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Trajectory::clear_force_reinit_new_goal_dist() {
  force_reinit_new_goal_dist_ = 0;
  clear_has_force_reinit_new_goal_dist();
}
inline float Trajectory::force_reinit_new_goal_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.force_reinit_new_goal_dist)
  return force_reinit_new_goal_dist_;
}
inline void Trajectory::set_force_reinit_new_goal_dist(float value) {
  set_has_force_reinit_new_goal_dist();
  force_reinit_new_goal_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.force_reinit_new_goal_dist)
}

// optional int64 feasibility_check_no_poses = 11;
inline bool Trajectory::has_feasibility_check_no_poses() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Trajectory::set_has_feasibility_check_no_poses() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Trajectory::clear_has_feasibility_check_no_poses() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Trajectory::clear_feasibility_check_no_poses() {
  feasibility_check_no_poses_ = GOOGLE_LONGLONG(0);
  clear_has_feasibility_check_no_poses();
}
inline ::google::protobuf::int64 Trajectory::feasibility_check_no_poses() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.feasibility_check_no_poses)
  return feasibility_check_no_poses_;
}
inline void Trajectory::set_feasibility_check_no_poses(::google::protobuf::int64 value) {
  set_has_feasibility_check_no_poses();
  feasibility_check_no_poses_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.feasibility_check_no_poses)
}

// optional bool publish_feedback = 12;
inline bool Trajectory::has_publish_feedback() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Trajectory::set_has_publish_feedback() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Trajectory::clear_has_publish_feedback() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Trajectory::clear_publish_feedback() {
  publish_feedback_ = false;
  clear_has_publish_feedback();
}
inline bool Trajectory::publish_feedback() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.publish_feedback)
  return publish_feedback_;
}
inline void Trajectory::set_publish_feedback(bool value) {
  set_has_publish_feedback();
  publish_feedback_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.publish_feedback)
}

// optional int64 min_samples = 13;
inline bool Trajectory::has_min_samples() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Trajectory::set_has_min_samples() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Trajectory::clear_has_min_samples() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Trajectory::clear_min_samples() {
  min_samples_ = GOOGLE_LONGLONG(0);
  clear_has_min_samples();
}
inline ::google::protobuf::int64 Trajectory::min_samples() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.min_samples)
  return min_samples_;
}
inline void Trajectory::set_min_samples(::google::protobuf::int64 value) {
  set_has_min_samples();
  min_samples_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.min_samples)
}

// optional int64 max_samples = 14;
inline bool Trajectory::has_max_samples() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Trajectory::set_has_max_samples() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Trajectory::clear_has_max_samples() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Trajectory::clear_max_samples() {
  max_samples_ = GOOGLE_LONGLONG(0);
  clear_has_max_samples();
}
inline ::google::protobuf::int64 Trajectory::max_samples() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Trajectory.max_samples)
  return max_samples_;
}
inline void Trajectory::set_max_samples(::google::protobuf::int64 value) {
  set_has_max_samples();
  max_samples_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Trajectory.max_samples)
}

// -------------------------------------------------------------------

// FootprintModel

// optional .roborts_local_planner.FootprintModel.FootprintType type = 1;
inline bool FootprintModel::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FootprintModel::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FootprintModel::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FootprintModel::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::roborts_local_planner::FootprintModel_FootprintType FootprintModel::type() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.type)
  return static_cast< ::roborts_local_planner::FootprintModel_FootprintType >(type_);
}
inline void FootprintModel::set_type(::roborts_local_planner::FootprintModel_FootprintType value) {
  assert(::roborts_local_planner::FootprintModel_FootprintType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.type)
}

// optional double radius = 2;
inline bool FootprintModel::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FootprintModel::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FootprintModel::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FootprintModel::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double FootprintModel::radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.radius)
  return radius_;
}
inline void FootprintModel::set_radius(double value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.radius)
}

// optional double front_offset = 3;
inline bool FootprintModel::has_front_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FootprintModel::set_has_front_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FootprintModel::clear_has_front_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FootprintModel::clear_front_offset() {
  front_offset_ = 0;
  clear_has_front_offset();
}
inline double FootprintModel::front_offset() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.front_offset)
  return front_offset_;
}
inline void FootprintModel::set_front_offset(double value) {
  set_has_front_offset();
  front_offset_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.front_offset)
}

// optional double front_radius = 4;
inline bool FootprintModel::has_front_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FootprintModel::set_has_front_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FootprintModel::clear_has_front_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FootprintModel::clear_front_radius() {
  front_radius_ = 0;
  clear_has_front_radius();
}
inline double FootprintModel::front_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.front_radius)
  return front_radius_;
}
inline void FootprintModel::set_front_radius(double value) {
  set_has_front_radius();
  front_radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.front_radius)
}

// optional double rear_offset = 5;
inline bool FootprintModel::has_rear_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FootprintModel::set_has_rear_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FootprintModel::clear_has_rear_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FootprintModel::clear_rear_offset() {
  rear_offset_ = 0;
  clear_has_rear_offset();
}
inline double FootprintModel::rear_offset() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.rear_offset)
  return rear_offset_;
}
inline void FootprintModel::set_rear_offset(double value) {
  set_has_rear_offset();
  rear_offset_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.rear_offset)
}

// optional double rear_radius = 6;
inline bool FootprintModel::has_rear_radius() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FootprintModel::set_has_rear_radius() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FootprintModel::clear_has_rear_radius() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FootprintModel::clear_rear_radius() {
  rear_radius_ = 0;
  clear_has_rear_radius();
}
inline double FootprintModel::rear_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.rear_radius)
  return rear_radius_;
}
inline void FootprintModel::set_rear_radius(double value) {
  set_has_rear_radius();
  rear_radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.FootprintModel.rear_radius)
}

// repeated .roborts_local_planner.Point2D robot_vertices = 7;
inline int FootprintModel::robot_vertices_size() const {
  return robot_vertices_.size();
}
inline void FootprintModel::clear_robot_vertices() {
  robot_vertices_.Clear();
}
inline ::roborts_local_planner::Point2D* FootprintModel::mutable_robot_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::Point2D >*
FootprintModel::mutable_robot_vertices() {
  // @@protoc_insertion_point(field_mutable_list:roborts_local_planner.FootprintModel.robot_vertices)
  return &robot_vertices_;
}
inline const ::roborts_local_planner::Point2D& FootprintModel::robot_vertices(int index) const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Get(index);
}
inline ::roborts_local_planner::Point2D* FootprintModel::add_robot_vertices() {
  // @@protoc_insertion_point(field_add:roborts_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::Point2D >&
FootprintModel::robot_vertices() const {
  // @@protoc_insertion_point(field_list:roborts_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_;
}

// -------------------------------------------------------------------

// Robot

// optional float max_vel_x = 1;
inline bool Robot::has_max_vel_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Robot::set_has_max_vel_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Robot::clear_has_max_vel_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Robot::clear_max_vel_x() {
  max_vel_x_ = 0;
  clear_has_max_vel_x();
}
inline float Robot::max_vel_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_x)
  return max_vel_x_;
}
inline void Robot::set_max_vel_x(float value) {
  set_has_max_vel_x();
  max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_x)
}

// optional float max_vel_x_backwards = 2;
inline bool Robot::has_max_vel_x_backwards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Robot::set_has_max_vel_x_backwards() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Robot::clear_has_max_vel_x_backwards() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Robot::clear_max_vel_x_backwards() {
  max_vel_x_backwards_ = 0;
  clear_has_max_vel_x_backwards();
}
inline float Robot::max_vel_x_backwards() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_x_backwards)
  return max_vel_x_backwards_;
}
inline void Robot::set_max_vel_x_backwards(float value) {
  set_has_max_vel_x_backwards();
  max_vel_x_backwards_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_x_backwards)
}

// optional float max_vel_y = 3;
inline bool Robot::has_max_vel_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Robot::set_has_max_vel_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Robot::clear_has_max_vel_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Robot::clear_max_vel_y() {
  max_vel_y_ = 0;
  clear_has_max_vel_y();
}
inline float Robot::max_vel_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_y)
  return max_vel_y_;
}
inline void Robot::set_max_vel_y(float value) {
  set_has_max_vel_y();
  max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_y)
}

// optional float max_vel_theta = 4;
inline bool Robot::has_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Robot::set_has_max_vel_theta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Robot::clear_has_max_vel_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Robot::clear_max_vel_theta() {
  max_vel_theta_ = 0;
  clear_has_max_vel_theta();
}
inline float Robot::max_vel_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.max_vel_theta)
  return max_vel_theta_;
}
inline void Robot::set_max_vel_theta(float value) {
  set_has_max_vel_theta();
  max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.max_vel_theta)
}

// optional float acc_lim_x = 5;
inline bool Robot::has_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Robot::set_has_acc_lim_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Robot::clear_has_acc_lim_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Robot::clear_acc_lim_x() {
  acc_lim_x_ = 0;
  clear_has_acc_lim_x();
}
inline float Robot::acc_lim_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.acc_lim_x)
  return acc_lim_x_;
}
inline void Robot::set_acc_lim_x(float value) {
  set_has_acc_lim_x();
  acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.acc_lim_x)
}

// optional float acc_lim_y = 6;
inline bool Robot::has_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Robot::set_has_acc_lim_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Robot::clear_has_acc_lim_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Robot::clear_acc_lim_y() {
  acc_lim_y_ = 0;
  clear_has_acc_lim_y();
}
inline float Robot::acc_lim_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.acc_lim_y)
  return acc_lim_y_;
}
inline void Robot::set_acc_lim_y(float value) {
  set_has_acc_lim_y();
  acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.acc_lim_y)
}

// optional float acc_lim_theta = 7;
inline bool Robot::has_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Robot::set_has_acc_lim_theta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Robot::clear_has_acc_lim_theta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Robot::clear_acc_lim_theta() {
  acc_lim_theta_ = 0;
  clear_has_acc_lim_theta();
}
inline float Robot::acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.acc_lim_theta)
  return acc_lim_theta_;
}
inline void Robot::set_acc_lim_theta(float value) {
  set_has_acc_lim_theta();
  acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.acc_lim_theta)
}

// optional float min_turning_radius = 8;
inline bool Robot::has_min_turning_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Robot::set_has_min_turning_radius() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Robot::clear_has_min_turning_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Robot::clear_min_turning_radius() {
  min_turning_radius_ = 0;
  clear_has_min_turning_radius();
}
inline float Robot::min_turning_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.min_turning_radius)
  return min_turning_radius_;
}
inline void Robot::set_min_turning_radius(float value) {
  set_has_min_turning_radius();
  min_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.min_turning_radius)
}

// optional float wheelbase = 9;
inline bool Robot::has_wheelbase() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Robot::set_has_wheelbase() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Robot::clear_has_wheelbase() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Robot::clear_wheelbase() {
  wheelbase_ = 0;
  clear_has_wheelbase();
}
inline float Robot::wheelbase() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.wheelbase)
  return wheelbase_;
}
inline void Robot::set_wheelbase(float value) {
  set_has_wheelbase();
  wheelbase_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.wheelbase)
}

// optional bool cmd_angle_instead_rotvel = 10;
inline bool Robot::has_cmd_angle_instead_rotvel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Robot::set_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Robot::clear_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Robot::clear_cmd_angle_instead_rotvel() {
  cmd_angle_instead_rotvel_ = false;
  clear_has_cmd_angle_instead_rotvel();
}
inline bool Robot::cmd_angle_instead_rotvel() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Robot.cmd_angle_instead_rotvel)
  return cmd_angle_instead_rotvel_;
}
inline void Robot::set_cmd_angle_instead_rotvel(bool value) {
  set_has_cmd_angle_instead_rotvel();
  cmd_angle_instead_rotvel_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Robot.cmd_angle_instead_rotvel)
}

// -------------------------------------------------------------------

// GoalTolerance

// optional float xy_goal_tolerance = 1;
inline bool GoalTolerance::has_xy_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoalTolerance::set_has_xy_goal_tolerance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoalTolerance::clear_has_xy_goal_tolerance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoalTolerance::clear_xy_goal_tolerance() {
  xy_goal_tolerance_ = 0;
  clear_has_xy_goal_tolerance();
}
inline float GoalTolerance::xy_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.GoalTolerance.xy_goal_tolerance)
  return xy_goal_tolerance_;
}
inline void GoalTolerance::set_xy_goal_tolerance(float value) {
  set_has_xy_goal_tolerance();
  xy_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.GoalTolerance.xy_goal_tolerance)
}

// optional float yaw_goal_tolerance = 2;
inline bool GoalTolerance::has_yaw_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoalTolerance::set_has_yaw_goal_tolerance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoalTolerance::clear_has_yaw_goal_tolerance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoalTolerance::clear_yaw_goal_tolerance() {
  yaw_goal_tolerance_ = 0;
  clear_has_yaw_goal_tolerance();
}
inline float GoalTolerance::yaw_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.GoalTolerance.yaw_goal_tolerance)
  return yaw_goal_tolerance_;
}
inline void GoalTolerance::set_yaw_goal_tolerance(float value) {
  set_has_yaw_goal_tolerance();
  yaw_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.GoalTolerance.yaw_goal_tolerance)
}

// optional bool free_goal_vel = 3;
inline bool GoalTolerance::has_free_goal_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoalTolerance::set_has_free_goal_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoalTolerance::clear_has_free_goal_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoalTolerance::clear_free_goal_vel() {
  free_goal_vel_ = false;
  clear_has_free_goal_vel();
}
inline bool GoalTolerance::free_goal_vel() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.GoalTolerance.free_goal_vel)
  return free_goal_vel_;
}
inline void GoalTolerance::set_free_goal_vel(bool value) {
  set_has_free_goal_vel();
  free_goal_vel_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.GoalTolerance.free_goal_vel)
}

// -------------------------------------------------------------------

// Obstacles

// optional float min_obstacle_dist = 1;
inline bool Obstacles::has_min_obstacle_dist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacles::set_has_min_obstacle_dist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacles::clear_has_min_obstacle_dist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacles::clear_min_obstacle_dist() {
  min_obstacle_dist_ = 0;
  clear_has_min_obstacle_dist();
}
inline float Obstacles::min_obstacle_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.min_obstacle_dist)
  return min_obstacle_dist_;
}
inline void Obstacles::set_min_obstacle_dist(float value) {
  set_has_min_obstacle_dist();
  min_obstacle_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.min_obstacle_dist)
}

// optional float inflation_dist = 2;
inline bool Obstacles::has_inflation_dist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacles::set_has_inflation_dist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacles::clear_has_inflation_dist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacles::clear_inflation_dist() {
  inflation_dist_ = 0;
  clear_has_inflation_dist();
}
inline float Obstacles::inflation_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.inflation_dist)
  return inflation_dist_;
}
inline void Obstacles::set_inflation_dist(float value) {
  set_has_inflation_dist();
  inflation_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.inflation_dist)
}

// optional bool include_costmap_obstacles = 3;
inline bool Obstacles::has_include_costmap_obstacles() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Obstacles::set_has_include_costmap_obstacles() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Obstacles::clear_has_include_costmap_obstacles() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Obstacles::clear_include_costmap_obstacles() {
  include_costmap_obstacles_ = false;
  clear_has_include_costmap_obstacles();
}
inline bool Obstacles::include_costmap_obstacles() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.include_costmap_obstacles)
  return include_costmap_obstacles_;
}
inline void Obstacles::set_include_costmap_obstacles(bool value) {
  set_has_include_costmap_obstacles();
  include_costmap_obstacles_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.include_costmap_obstacles)
}

// optional float costmap_obstacles_behind_robot_dist = 4;
inline bool Obstacles::has_costmap_obstacles_behind_robot_dist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacles::set_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacles::clear_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacles::clear_costmap_obstacles_behind_robot_dist() {
  costmap_obstacles_behind_robot_dist_ = 0;
  clear_has_costmap_obstacles_behind_robot_dist();
}
inline float Obstacles::costmap_obstacles_behind_robot_dist() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
  return costmap_obstacles_behind_robot_dist_;
}
inline void Obstacles::set_costmap_obstacles_behind_robot_dist(float value) {
  set_has_costmap_obstacles_behind_robot_dist();
  costmap_obstacles_behind_robot_dist_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
}

// optional float obstacle_poses_affected = 5;
inline bool Obstacles::has_obstacle_poses_affected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Obstacles::set_has_obstacle_poses_affected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Obstacles::clear_has_obstacle_poses_affected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Obstacles::clear_obstacle_poses_affected() {
  obstacle_poses_affected_ = 0;
  clear_has_obstacle_poses_affected();
}
inline float Obstacles::obstacle_poses_affected() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.obstacle_poses_affected)
  return obstacle_poses_affected_;
}
inline void Obstacles::set_obstacle_poses_affected(float value) {
  set_has_obstacle_poses_affected();
  obstacle_poses_affected_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.obstacle_poses_affected)
}

// optional bool legacy_obstacle_association = 6;
inline bool Obstacles::has_legacy_obstacle_association() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Obstacles::set_has_legacy_obstacle_association() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Obstacles::clear_has_legacy_obstacle_association() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Obstacles::clear_legacy_obstacle_association() {
  legacy_obstacle_association_ = false;
  clear_has_legacy_obstacle_association();
}
inline bool Obstacles::legacy_obstacle_association() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.legacy_obstacle_association)
  return legacy_obstacle_association_;
}
inline void Obstacles::set_legacy_obstacle_association(bool value) {
  set_has_legacy_obstacle_association();
  legacy_obstacle_association_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.legacy_obstacle_association)
}

// optional float obstacle_association_cutoff_factor = 7;
inline bool Obstacles::has_obstacle_association_cutoff_factor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Obstacles::set_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Obstacles::clear_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Obstacles::clear_obstacle_association_cutoff_factor() {
  obstacle_association_cutoff_factor_ = 0;
  clear_has_obstacle_association_cutoff_factor();
}
inline float Obstacles::obstacle_association_cutoff_factor() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.obstacle_association_cutoff_factor)
  return obstacle_association_cutoff_factor_;
}
inline void Obstacles::set_obstacle_association_cutoff_factor(float value) {
  set_has_obstacle_association_cutoff_factor();
  obstacle_association_cutoff_factor_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.obstacle_association_cutoff_factor)
}

// optional float obstacle_association_force_inclusion_factor = 8;
inline bool Obstacles::has_obstacle_association_force_inclusion_factor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Obstacles::set_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Obstacles::clear_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Obstacles::clear_obstacle_association_force_inclusion_factor() {
  obstacle_association_force_inclusion_factor_ = 0;
  clear_has_obstacle_association_force_inclusion_factor();
}
inline float Obstacles::obstacle_association_force_inclusion_factor() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.obstacle_association_force_inclusion_factor)
  return obstacle_association_force_inclusion_factor_;
}
inline void Obstacles::set_obstacle_association_force_inclusion_factor(float value) {
  set_has_obstacle_association_force_inclusion_factor();
  obstacle_association_force_inclusion_factor_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.obstacle_association_force_inclusion_factor)
}

// optional string costmap_converter_plugin = 9;
inline bool Obstacles::has_costmap_converter_plugin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacles::set_has_costmap_converter_plugin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacles::clear_has_costmap_converter_plugin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacles::clear_costmap_converter_plugin() {
  costmap_converter_plugin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_costmap_converter_plugin();
}
inline const ::std::string& Obstacles::costmap_converter_plugin() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_converter_plugin)
  return costmap_converter_plugin_.GetNoArena();
}
inline void Obstacles::set_costmap_converter_plugin(const ::std::string& value) {
  set_has_costmap_converter_plugin();
  costmap_converter_plugin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_converter_plugin)
}
#if LANG_CXX11
inline void Obstacles::set_costmap_converter_plugin(::std::string&& value) {
  set_has_costmap_converter_plugin();
  costmap_converter_plugin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:roborts_local_planner.Obstacles.costmap_converter_plugin)
}
#endif
inline void Obstacles::set_costmap_converter_plugin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_costmap_converter_plugin();
  costmap_converter_plugin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roborts_local_planner.Obstacles.costmap_converter_plugin)
}
inline void Obstacles::set_costmap_converter_plugin(const char* value, size_t size) {
  set_has_costmap_converter_plugin();
  costmap_converter_plugin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roborts_local_planner.Obstacles.costmap_converter_plugin)
}
inline ::std::string* Obstacles::mutable_costmap_converter_plugin() {
  set_has_costmap_converter_plugin();
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Obstacles.costmap_converter_plugin)
  return costmap_converter_plugin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Obstacles::release_costmap_converter_plugin() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Obstacles.costmap_converter_plugin)
  if (!has_costmap_converter_plugin()) {
    return NULL;
  }
  clear_has_costmap_converter_plugin();
  return costmap_converter_plugin_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Obstacles::set_allocated_costmap_converter_plugin(::std::string* costmap_converter_plugin) {
  if (costmap_converter_plugin != NULL) {
    set_has_costmap_converter_plugin();
  } else {
    clear_has_costmap_converter_plugin();
  }
  costmap_converter_plugin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), costmap_converter_plugin);
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Obstacles.costmap_converter_plugin)
}

// optional bool costmap_converter_spin_thread = 10;
inline bool Obstacles::has_costmap_converter_spin_thread() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Obstacles::set_has_costmap_converter_spin_thread() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Obstacles::clear_has_costmap_converter_spin_thread() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Obstacles::clear_costmap_converter_spin_thread() {
  costmap_converter_spin_thread_ = false;
  clear_has_costmap_converter_spin_thread();
}
inline bool Obstacles::costmap_converter_spin_thread() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_converter_spin_thread)
  return costmap_converter_spin_thread_;
}
inline void Obstacles::set_costmap_converter_spin_thread(bool value) {
  set_has_costmap_converter_spin_thread();
  costmap_converter_spin_thread_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_converter_spin_thread)
}

// optional float costmap_converter_rate = 11;
inline bool Obstacles::has_costmap_converter_rate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Obstacles::set_has_costmap_converter_rate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Obstacles::clear_has_costmap_converter_rate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Obstacles::clear_costmap_converter_rate() {
  costmap_converter_rate_ = 0;
  clear_has_costmap_converter_rate();
}
inline float Obstacles::costmap_converter_rate() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Obstacles.costmap_converter_rate)
  return costmap_converter_rate_;
}
inline void Obstacles::set_costmap_converter_rate(float value) {
  set_has_costmap_converter_rate();
  costmap_converter_rate_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Obstacles.costmap_converter_rate)
}

// -------------------------------------------------------------------

// Optimization

// optional int32 no_inner_iterations = 1;
inline bool Optimization::has_no_inner_iterations() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Optimization::set_has_no_inner_iterations() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Optimization::clear_has_no_inner_iterations() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Optimization::clear_no_inner_iterations() {
  no_inner_iterations_ = 0;
  clear_has_no_inner_iterations();
}
inline ::google::protobuf::int32 Optimization::no_inner_iterations() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.no_inner_iterations)
  return no_inner_iterations_;
}
inline void Optimization::set_no_inner_iterations(::google::protobuf::int32 value) {
  set_has_no_inner_iterations();
  no_inner_iterations_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.no_inner_iterations)
}

// optional int32 no_outer_iterations = 2;
inline bool Optimization::has_no_outer_iterations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Optimization::set_has_no_outer_iterations() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Optimization::clear_has_no_outer_iterations() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Optimization::clear_no_outer_iterations() {
  no_outer_iterations_ = 0;
  clear_has_no_outer_iterations();
}
inline ::google::protobuf::int32 Optimization::no_outer_iterations() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.no_outer_iterations)
  return no_outer_iterations_;
}
inline void Optimization::set_no_outer_iterations(::google::protobuf::int32 value) {
  set_has_no_outer_iterations();
  no_outer_iterations_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.no_outer_iterations)
}

// optional bool optimization_activate = 3;
inline bool Optimization::has_optimization_activate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Optimization::set_has_optimization_activate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Optimization::clear_has_optimization_activate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Optimization::clear_optimization_activate() {
  optimization_activate_ = false;
  clear_has_optimization_activate();
}
inline bool Optimization::optimization_activate() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.optimization_activate)
  return optimization_activate_;
}
inline void Optimization::set_optimization_activate(bool value) {
  set_has_optimization_activate();
  optimization_activate_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.optimization_activate)
}

// optional bool optimization_verbose = 4;
inline bool Optimization::has_optimization_verbose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Optimization::set_has_optimization_verbose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Optimization::clear_has_optimization_verbose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Optimization::clear_optimization_verbose() {
  optimization_verbose_ = false;
  clear_has_optimization_verbose();
}
inline bool Optimization::optimization_verbose() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.optimization_verbose)
  return optimization_verbose_;
}
inline void Optimization::set_optimization_verbose(bool value) {
  set_has_optimization_verbose();
  optimization_verbose_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.optimization_verbose)
}

// optional float penalty_epsilon = 5;
inline bool Optimization::has_penalty_epsilon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Optimization::set_has_penalty_epsilon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Optimization::clear_has_penalty_epsilon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Optimization::clear_penalty_epsilon() {
  penalty_epsilon_ = 0;
  clear_has_penalty_epsilon();
}
inline float Optimization::penalty_epsilon() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.penalty_epsilon)
  return penalty_epsilon_;
}
inline void Optimization::set_penalty_epsilon(float value) {
  set_has_penalty_epsilon();
  penalty_epsilon_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.penalty_epsilon)
}

// optional float weight_max_vel_x = 6;
inline bool Optimization::has_weight_max_vel_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Optimization::set_has_weight_max_vel_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Optimization::clear_has_weight_max_vel_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Optimization::clear_weight_max_vel_x() {
  weight_max_vel_x_ = 0;
  clear_has_weight_max_vel_x();
}
inline float Optimization::weight_max_vel_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_max_vel_x)
  return weight_max_vel_x_;
}
inline void Optimization::set_weight_max_vel_x(float value) {
  set_has_weight_max_vel_x();
  weight_max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_max_vel_x)
}

// optional float weight_max_vel_y = 7;
inline bool Optimization::has_weight_max_vel_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Optimization::set_has_weight_max_vel_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Optimization::clear_has_weight_max_vel_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Optimization::clear_weight_max_vel_y() {
  weight_max_vel_y_ = 0;
  clear_has_weight_max_vel_y();
}
inline float Optimization::weight_max_vel_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_max_vel_y)
  return weight_max_vel_y_;
}
inline void Optimization::set_weight_max_vel_y(float value) {
  set_has_weight_max_vel_y();
  weight_max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_max_vel_y)
}

// optional float weight_max_vel_theta = 8;
inline bool Optimization::has_weight_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Optimization::set_has_weight_max_vel_theta() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Optimization::clear_has_weight_max_vel_theta() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Optimization::clear_weight_max_vel_theta() {
  weight_max_vel_theta_ = 0;
  clear_has_weight_max_vel_theta();
}
inline float Optimization::weight_max_vel_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_max_vel_theta)
  return weight_max_vel_theta_;
}
inline void Optimization::set_weight_max_vel_theta(float value) {
  set_has_weight_max_vel_theta();
  weight_max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_max_vel_theta)
}

// optional float weight_acc_lim_x = 9;
inline bool Optimization::has_weight_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_x() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Optimization::clear_has_weight_acc_lim_x() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Optimization::clear_weight_acc_lim_x() {
  weight_acc_lim_x_ = 0;
  clear_has_weight_acc_lim_x();
}
inline float Optimization::weight_acc_lim_x() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_x)
  return weight_acc_lim_x_;
}
inline void Optimization::set_weight_acc_lim_x(float value) {
  set_has_weight_acc_lim_x();
  weight_acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_x)
}

// optional float weight_acc_lim_y = 10;
inline bool Optimization::has_weight_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Optimization::clear_has_weight_acc_lim_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Optimization::clear_weight_acc_lim_y() {
  weight_acc_lim_y_ = 0;
  clear_has_weight_acc_lim_y();
}
inline float Optimization::weight_acc_lim_y() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_y)
  return weight_acc_lim_y_;
}
inline void Optimization::set_weight_acc_lim_y(float value) {
  set_has_weight_acc_lim_y();
  weight_acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_y)
}

// optional float weight_acc_lim_thet = 11;
inline bool Optimization::has_weight_acc_lim_thet() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_thet() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Optimization::clear_has_weight_acc_lim_thet() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Optimization::clear_weight_acc_lim_thet() {
  weight_acc_lim_thet_ = 0;
  clear_has_weight_acc_lim_thet();
}
inline float Optimization::weight_acc_lim_thet() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_thet)
  return weight_acc_lim_thet_;
}
inline void Optimization::set_weight_acc_lim_thet(float value) {
  set_has_weight_acc_lim_thet();
  weight_acc_lim_thet_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_thet)
}

// optional float weight_kinematics_nh = 12;
inline bool Optimization::has_weight_kinematics_nh() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Optimization::set_has_weight_kinematics_nh() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Optimization::clear_has_weight_kinematics_nh() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Optimization::clear_weight_kinematics_nh() {
  weight_kinematics_nh_ = 0;
  clear_has_weight_kinematics_nh();
}
inline float Optimization::weight_kinematics_nh() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_kinematics_nh)
  return weight_kinematics_nh_;
}
inline void Optimization::set_weight_kinematics_nh(float value) {
  set_has_weight_kinematics_nh();
  weight_kinematics_nh_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_kinematics_nh)
}

// optional float weight_kinematics_forward_drive = 13;
inline bool Optimization::has_weight_kinematics_forward_drive() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Optimization::set_has_weight_kinematics_forward_drive() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Optimization::clear_has_weight_kinematics_forward_drive() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Optimization::clear_weight_kinematics_forward_drive() {
  weight_kinematics_forward_drive_ = 0;
  clear_has_weight_kinematics_forward_drive();
}
inline float Optimization::weight_kinematics_forward_drive() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_kinematics_forward_drive)
  return weight_kinematics_forward_drive_;
}
inline void Optimization::set_weight_kinematics_forward_drive(float value) {
  set_has_weight_kinematics_forward_drive();
  weight_kinematics_forward_drive_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_kinematics_forward_drive)
}

// optional float weight_kinematics_turning_radius = 14;
inline bool Optimization::has_weight_kinematics_turning_radius() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Optimization::set_has_weight_kinematics_turning_radius() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Optimization::clear_has_weight_kinematics_turning_radius() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Optimization::clear_weight_kinematics_turning_radius() {
  weight_kinematics_turning_radius_ = 0;
  clear_has_weight_kinematics_turning_radius();
}
inline float Optimization::weight_kinematics_turning_radius() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_kinematics_turning_radius)
  return weight_kinematics_turning_radius_;
}
inline void Optimization::set_weight_kinematics_turning_radius(float value) {
  set_has_weight_kinematics_turning_radius();
  weight_kinematics_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_kinematics_turning_radius)
}

// optional float weight_optimaltime = 15;
inline bool Optimization::has_weight_optimaltime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Optimization::set_has_weight_optimaltime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Optimization::clear_has_weight_optimaltime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Optimization::clear_weight_optimaltime() {
  weight_optimaltime_ = 0;
  clear_has_weight_optimaltime();
}
inline float Optimization::weight_optimaltime() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_optimaltime)
  return weight_optimaltime_;
}
inline void Optimization::set_weight_optimaltime(float value) {
  set_has_weight_optimaltime();
  weight_optimaltime_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_optimaltime)
}

// optional float weight_obstacle = 16;
inline bool Optimization::has_weight_obstacle() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Optimization::set_has_weight_obstacle() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Optimization::clear_has_weight_obstacle() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Optimization::clear_weight_obstacle() {
  weight_obstacle_ = 0;
  clear_has_weight_obstacle();
}
inline float Optimization::weight_obstacle() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_obstacle)
  return weight_obstacle_;
}
inline void Optimization::set_weight_obstacle(float value) {
  set_has_weight_obstacle();
  weight_obstacle_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_obstacle)
}

// optional float weight_inflation = 17;
inline bool Optimization::has_weight_inflation() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Optimization::set_has_weight_inflation() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Optimization::clear_has_weight_inflation() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Optimization::clear_weight_inflation() {
  weight_inflation_ = 0;
  clear_has_weight_inflation();
}
inline float Optimization::weight_inflation() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_inflation)
  return weight_inflation_;
}
inline void Optimization::set_weight_inflation(float value) {
  set_has_weight_inflation();
  weight_inflation_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_inflation)
}

// optional float weight_dynamic_obstacle = 18;
inline bool Optimization::has_weight_dynamic_obstacle() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Optimization::set_has_weight_dynamic_obstacle() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Optimization::clear_has_weight_dynamic_obstacle() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Optimization::clear_weight_dynamic_obstacle() {
  weight_dynamic_obstacle_ = 0;
  clear_has_weight_dynamic_obstacle();
}
inline float Optimization::weight_dynamic_obstacle() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_dynamic_obstacle)
  return weight_dynamic_obstacle_;
}
inline void Optimization::set_weight_dynamic_obstacle(float value) {
  set_has_weight_dynamic_obstacle();
  weight_dynamic_obstacle_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_dynamic_obstacle)
}

// optional float weight_viapoint = 19;
inline bool Optimization::has_weight_viapoint() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Optimization::set_has_weight_viapoint() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Optimization::clear_has_weight_viapoint() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Optimization::clear_weight_viapoint() {
  weight_viapoint_ = 0;
  clear_has_weight_viapoint();
}
inline float Optimization::weight_viapoint() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_viapoint)
  return weight_viapoint_;
}
inline void Optimization::set_weight_viapoint(float value) {
  set_has_weight_viapoint();
  weight_viapoint_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_viapoint)
}

// optional float weight_adapt_factor = 20;
inline bool Optimization::has_weight_adapt_factor() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Optimization::set_has_weight_adapt_factor() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Optimization::clear_has_weight_adapt_factor() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Optimization::clear_weight_adapt_factor() {
  weight_adapt_factor_ = 0;
  clear_has_weight_adapt_factor();
}
inline float Optimization::weight_adapt_factor() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_adapt_factor)
  return weight_adapt_factor_;
}
inline void Optimization::set_weight_adapt_factor(float value) {
  set_has_weight_adapt_factor();
  weight_adapt_factor_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_adapt_factor)
}

// optional float weight_prefer_rotdir = 21;
inline bool Optimization::has_weight_prefer_rotdir() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Optimization::set_has_weight_prefer_rotdir() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Optimization::clear_has_weight_prefer_rotdir() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Optimization::clear_weight_prefer_rotdir() {
  weight_prefer_rotdir_ = 0;
  clear_has_weight_prefer_rotdir();
}
inline float Optimization::weight_prefer_rotdir() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_prefer_rotdir)
  return weight_prefer_rotdir_;
}
inline void Optimization::set_weight_prefer_rotdir(float value) {
  set_has_weight_prefer_rotdir();
  weight_prefer_rotdir_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_prefer_rotdir)
}

// optional float weight_acc_lim_theta = 22;
inline bool Optimization::has_weight_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_theta() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Optimization::clear_has_weight_acc_lim_theta() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Optimization::clear_weight_acc_lim_theta() {
  weight_acc_lim_theta_ = 0;
  clear_has_weight_acc_lim_theta();
}
inline float Optimization::weight_acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Optimization.weight_acc_lim_theta)
  return weight_acc_lim_theta_;
}
inline void Optimization::set_weight_acc_lim_theta(float value) {
  set_has_weight_acc_lim_theta();
  weight_acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Optimization.weight_acc_lim_theta)
}

// -------------------------------------------------------------------

// HomotopyClassPlanner

// optional bool enable_homotopy_class_planning = 1;
inline bool HomotopyClassPlanner::has_enable_homotopy_class_planning() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HomotopyClassPlanner::set_has_enable_homotopy_class_planning() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HomotopyClassPlanner::clear_has_enable_homotopy_class_planning() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HomotopyClassPlanner::clear_enable_homotopy_class_planning() {
  enable_homotopy_class_planning_ = false;
  clear_has_enable_homotopy_class_planning();
}
inline bool HomotopyClassPlanner::enable_homotopy_class_planning() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.enable_homotopy_class_planning)
  return enable_homotopy_class_planning_;
}
inline void HomotopyClassPlanner::set_enable_homotopy_class_planning(bool value) {
  set_has_enable_homotopy_class_planning();
  enable_homotopy_class_planning_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.enable_homotopy_class_planning)
}

// optional bool enable_multithreading = 2;
inline bool HomotopyClassPlanner::has_enable_multithreading() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HomotopyClassPlanner::set_has_enable_multithreading() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HomotopyClassPlanner::clear_has_enable_multithreading() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HomotopyClassPlanner::clear_enable_multithreading() {
  enable_multithreading_ = false;
  clear_has_enable_multithreading();
}
inline bool HomotopyClassPlanner::enable_multithreading() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.enable_multithreading)
  return enable_multithreading_;
}
inline void HomotopyClassPlanner::set_enable_multithreading(bool value) {
  set_has_enable_multithreading();
  enable_multithreading_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.enable_multithreading)
}

// optional bool simple_exploration = 3;
inline bool HomotopyClassPlanner::has_simple_exploration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HomotopyClassPlanner::set_has_simple_exploration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HomotopyClassPlanner::clear_has_simple_exploration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HomotopyClassPlanner::clear_simple_exploration() {
  simple_exploration_ = false;
  clear_has_simple_exploration();
}
inline bool HomotopyClassPlanner::simple_exploration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.simple_exploration)
  return simple_exploration_;
}
inline void HomotopyClassPlanner::set_simple_exploration(bool value) {
  set_has_simple_exploration();
  simple_exploration_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.simple_exploration)
}

// optional int32 max_number_classes = 4;
inline bool HomotopyClassPlanner::has_max_number_classes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HomotopyClassPlanner::set_has_max_number_classes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HomotopyClassPlanner::clear_has_max_number_classes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HomotopyClassPlanner::clear_max_number_classes() {
  max_number_classes_ = 0;
  clear_has_max_number_classes();
}
inline ::google::protobuf::int32 HomotopyClassPlanner::max_number_classes() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.max_number_classes)
  return max_number_classes_;
}
inline void HomotopyClassPlanner::set_max_number_classes(::google::protobuf::int32 value) {
  set_has_max_number_classes();
  max_number_classes_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.max_number_classes)
}

// optional float selection_obst_cost_scale = 5;
inline bool HomotopyClassPlanner::has_selection_obst_cost_scale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_obst_cost_scale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HomotopyClassPlanner::clear_has_selection_obst_cost_scale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HomotopyClassPlanner::clear_selection_obst_cost_scale() {
  selection_obst_cost_scale_ = 0;
  clear_has_selection_obst_cost_scale();
}
inline float HomotopyClassPlanner::selection_obst_cost_scale() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_obst_cost_scale)
  return selection_obst_cost_scale_;
}
inline void HomotopyClassPlanner::set_selection_obst_cost_scale(float value) {
  set_has_selection_obst_cost_scale();
  selection_obst_cost_scale_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_obst_cost_scale)
}

// optional float selection_prefer_initial_plan = 6;
inline bool HomotopyClassPlanner::has_selection_prefer_initial_plan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_prefer_initial_plan() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HomotopyClassPlanner::clear_has_selection_prefer_initial_plan() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HomotopyClassPlanner::clear_selection_prefer_initial_plan() {
  selection_prefer_initial_plan_ = 0;
  clear_has_selection_prefer_initial_plan();
}
inline float HomotopyClassPlanner::selection_prefer_initial_plan() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_prefer_initial_plan)
  return selection_prefer_initial_plan_;
}
inline void HomotopyClassPlanner::set_selection_prefer_initial_plan(float value) {
  set_has_selection_prefer_initial_plan();
  selection_prefer_initial_plan_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_prefer_initial_plan)
}

// optional float selection_viapoint_cost_scale = 7;
inline bool HomotopyClassPlanner::has_selection_viapoint_cost_scale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_viapoint_cost_scale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HomotopyClassPlanner::clear_has_selection_viapoint_cost_scale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HomotopyClassPlanner::clear_selection_viapoint_cost_scale() {
  selection_viapoint_cost_scale_ = 0;
  clear_has_selection_viapoint_cost_scale();
}
inline float HomotopyClassPlanner::selection_viapoint_cost_scale() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_viapoint_cost_scale)
  return selection_viapoint_cost_scale_;
}
inline void HomotopyClassPlanner::set_selection_viapoint_cost_scale(float value) {
  set_has_selection_viapoint_cost_scale();
  selection_viapoint_cost_scale_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_viapoint_cost_scale)
}

// optional float selection_cost_hysteresis = 8;
inline bool HomotopyClassPlanner::has_selection_cost_hysteresis() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_cost_hysteresis() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HomotopyClassPlanner::clear_has_selection_cost_hysteresis() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HomotopyClassPlanner::clear_selection_cost_hysteresis() {
  selection_cost_hysteresis_ = 0;
  clear_has_selection_cost_hysteresis();
}
inline float HomotopyClassPlanner::selection_cost_hysteresis() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_cost_hysteresis)
  return selection_cost_hysteresis_;
}
inline void HomotopyClassPlanner::set_selection_cost_hysteresis(float value) {
  set_has_selection_cost_hysteresis();
  selection_cost_hysteresis_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_cost_hysteresis)
}

// optional bool selection_alternative_time_cost = 9;
inline bool HomotopyClassPlanner::has_selection_alternative_time_cost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_alternative_time_cost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HomotopyClassPlanner::clear_has_selection_alternative_time_cost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HomotopyClassPlanner::clear_selection_alternative_time_cost() {
  selection_alternative_time_cost_ = false;
  clear_has_selection_alternative_time_cost();
}
inline bool HomotopyClassPlanner::selection_alternative_time_cost() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.selection_alternative_time_cost)
  return selection_alternative_time_cost_;
}
inline void HomotopyClassPlanner::set_selection_alternative_time_cost(bool value) {
  set_has_selection_alternative_time_cost();
  selection_alternative_time_cost_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.selection_alternative_time_cost)
}

// optional int32 roadmap_graph_no_samples = 10;
inline bool HomotopyClassPlanner::has_roadmap_graph_no_samples() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HomotopyClassPlanner::set_has_roadmap_graph_no_samples() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HomotopyClassPlanner::clear_has_roadmap_graph_no_samples() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HomotopyClassPlanner::clear_roadmap_graph_no_samples() {
  roadmap_graph_no_samples_ = 0;
  clear_has_roadmap_graph_no_samples();
}
inline ::google::protobuf::int32 HomotopyClassPlanner::roadmap_graph_no_samples() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_no_samples)
  return roadmap_graph_no_samples_;
}
inline void HomotopyClassPlanner::set_roadmap_graph_no_samples(::google::protobuf::int32 value) {
  set_has_roadmap_graph_no_samples();
  roadmap_graph_no_samples_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_no_samples)
}

// optional int32 roadmap_graph_area_width = 11;
inline bool HomotopyClassPlanner::has_roadmap_graph_area_width() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HomotopyClassPlanner::set_has_roadmap_graph_area_width() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HomotopyClassPlanner::clear_has_roadmap_graph_area_width() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HomotopyClassPlanner::clear_roadmap_graph_area_width() {
  roadmap_graph_area_width_ = 0;
  clear_has_roadmap_graph_area_width();
}
inline ::google::protobuf::int32 HomotopyClassPlanner::roadmap_graph_area_width() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_width)
  return roadmap_graph_area_width_;
}
inline void HomotopyClassPlanner::set_roadmap_graph_area_width(::google::protobuf::int32 value) {
  set_has_roadmap_graph_area_width();
  roadmap_graph_area_width_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_width)
}

// optional float roadmap_graph_area_length_scale = 12;
inline bool HomotopyClassPlanner::has_roadmap_graph_area_length_scale() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HomotopyClassPlanner::set_has_roadmap_graph_area_length_scale() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HomotopyClassPlanner::clear_has_roadmap_graph_area_length_scale() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HomotopyClassPlanner::clear_roadmap_graph_area_length_scale() {
  roadmap_graph_area_length_scale_ = 0;
  clear_has_roadmap_graph_area_length_scale();
}
inline float HomotopyClassPlanner::roadmap_graph_area_length_scale() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_length_scale)
  return roadmap_graph_area_length_scale_;
}
inline void HomotopyClassPlanner::set_roadmap_graph_area_length_scale(float value) {
  set_has_roadmap_graph_area_length_scale();
  roadmap_graph_area_length_scale_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.roadmap_graph_area_length_scale)
}

// optional float h_signature_prescaler = 13;
inline bool HomotopyClassPlanner::has_h_signature_prescaler() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HomotopyClassPlanner::set_has_h_signature_prescaler() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HomotopyClassPlanner::clear_has_h_signature_prescaler() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HomotopyClassPlanner::clear_h_signature_prescaler() {
  h_signature_prescaler_ = 0;
  clear_has_h_signature_prescaler();
}
inline float HomotopyClassPlanner::h_signature_prescaler() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.h_signature_prescaler)
  return h_signature_prescaler_;
}
inline void HomotopyClassPlanner::set_h_signature_prescaler(float value) {
  set_has_h_signature_prescaler();
  h_signature_prescaler_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.h_signature_prescaler)
}

// optional float h_signature_threshold = 14;
inline bool HomotopyClassPlanner::has_h_signature_threshold() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void HomotopyClassPlanner::set_has_h_signature_threshold() {
  _has_bits_[0] |= 0x00002000u;
}
inline void HomotopyClassPlanner::clear_has_h_signature_threshold() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void HomotopyClassPlanner::clear_h_signature_threshold() {
  h_signature_threshold_ = 0;
  clear_has_h_signature_threshold();
}
inline float HomotopyClassPlanner::h_signature_threshold() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.h_signature_threshold)
  return h_signature_threshold_;
}
inline void HomotopyClassPlanner::set_h_signature_threshold(float value) {
  set_has_h_signature_threshold();
  h_signature_threshold_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.h_signature_threshold)
}

// optional float obstacle_keypoint_offset = 15;
inline bool HomotopyClassPlanner::has_obstacle_keypoint_offset() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void HomotopyClassPlanner::set_has_obstacle_keypoint_offset() {
  _has_bits_[0] |= 0x00004000u;
}
inline void HomotopyClassPlanner::clear_has_obstacle_keypoint_offset() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void HomotopyClassPlanner::clear_obstacle_keypoint_offset() {
  obstacle_keypoint_offset_ = 0;
  clear_has_obstacle_keypoint_offset();
}
inline float HomotopyClassPlanner::obstacle_keypoint_offset() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.obstacle_keypoint_offset)
  return obstacle_keypoint_offset_;
}
inline void HomotopyClassPlanner::set_obstacle_keypoint_offset(float value) {
  set_has_obstacle_keypoint_offset();
  obstacle_keypoint_offset_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.obstacle_keypoint_offset)
}

// optional float obstacle_heading_threshold = 16;
inline bool HomotopyClassPlanner::has_obstacle_heading_threshold() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void HomotopyClassPlanner::set_has_obstacle_heading_threshold() {
  _has_bits_[0] |= 0x00008000u;
}
inline void HomotopyClassPlanner::clear_has_obstacle_heading_threshold() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void HomotopyClassPlanner::clear_obstacle_heading_threshold() {
  obstacle_heading_threshold_ = 0;
  clear_has_obstacle_heading_threshold();
}
inline float HomotopyClassPlanner::obstacle_heading_threshold() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.obstacle_heading_threshold)
  return obstacle_heading_threshold_;
}
inline void HomotopyClassPlanner::set_obstacle_heading_threshold(float value) {
  set_has_obstacle_heading_threshold();
  obstacle_heading_threshold_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.obstacle_heading_threshold)
}

// optional bool viapoints_all_candidates = 17;
inline bool HomotopyClassPlanner::has_viapoints_all_candidates() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void HomotopyClassPlanner::set_has_viapoints_all_candidates() {
  _has_bits_[0] |= 0x00010000u;
}
inline void HomotopyClassPlanner::clear_has_viapoints_all_candidates() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void HomotopyClassPlanner::clear_viapoints_all_candidates() {
  viapoints_all_candidates_ = false;
  clear_has_viapoints_all_candidates();
}
inline bool HomotopyClassPlanner::viapoints_all_candidates() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.viapoints_all_candidates)
  return viapoints_all_candidates_;
}
inline void HomotopyClassPlanner::set_viapoints_all_candidates(bool value) {
  set_has_viapoints_all_candidates();
  viapoints_all_candidates_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.viapoints_all_candidates)
}

// optional bool visualize_hc_graph = 18;
inline bool HomotopyClassPlanner::has_visualize_hc_graph() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void HomotopyClassPlanner::set_has_visualize_hc_graph() {
  _has_bits_[0] |= 0x00020000u;
}
inline void HomotopyClassPlanner::clear_has_visualize_hc_graph() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void HomotopyClassPlanner::clear_visualize_hc_graph() {
  visualize_hc_graph_ = false;
  clear_has_visualize_hc_graph();
}
inline bool HomotopyClassPlanner::visualize_hc_graph() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.HomotopyClassPlanner.visualize_hc_graph)
  return visualize_hc_graph_;
}
inline void HomotopyClassPlanner::set_visualize_hc_graph(bool value) {
  set_has_visualize_hc_graph();
  visualize_hc_graph_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.HomotopyClassPlanner.visualize_hc_graph)
}

// -------------------------------------------------------------------

// Recovery

// optional bool shrink_horizon_min_duration = 1;
inline bool Recovery::has_shrink_horizon_min_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Recovery::set_has_shrink_horizon_min_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Recovery::clear_has_shrink_horizon_min_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Recovery::clear_shrink_horizon_min_duration() {
  shrink_horizon_min_duration_ = false;
  clear_has_shrink_horizon_min_duration();
}
inline bool Recovery::shrink_horizon_min_duration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.shrink_horizon_min_duration)
  return shrink_horizon_min_duration_;
}
inline void Recovery::set_shrink_horizon_min_duration(bool value) {
  set_has_shrink_horizon_min_duration();
  shrink_horizon_min_duration_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.shrink_horizon_min_duration)
}

// optional bool oscillation_recovery = 2;
inline bool Recovery::has_oscillation_recovery() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Recovery::set_has_oscillation_recovery() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Recovery::clear_has_oscillation_recovery() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Recovery::clear_oscillation_recovery() {
  oscillation_recovery_ = false;
  clear_has_oscillation_recovery();
}
inline bool Recovery::oscillation_recovery() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_recovery)
  return oscillation_recovery_;
}
inline void Recovery::set_oscillation_recovery(bool value) {
  set_has_oscillation_recovery();
  oscillation_recovery_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_recovery)
}

// optional bool shrink_horizon_backup = 3;
inline bool Recovery::has_shrink_horizon_backup() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Recovery::set_has_shrink_horizon_backup() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Recovery::clear_has_shrink_horizon_backup() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Recovery::clear_shrink_horizon_backup() {
  shrink_horizon_backup_ = false;
  clear_has_shrink_horizon_backup();
}
inline bool Recovery::shrink_horizon_backup() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.shrink_horizon_backup)
  return shrink_horizon_backup_;
}
inline void Recovery::set_shrink_horizon_backup(bool value) {
  set_has_shrink_horizon_backup();
  shrink_horizon_backup_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.shrink_horizon_backup)
}

// optional double oscillation_v_eps = 4;
inline bool Recovery::has_oscillation_v_eps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Recovery::set_has_oscillation_v_eps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Recovery::clear_has_oscillation_v_eps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Recovery::clear_oscillation_v_eps() {
  oscillation_v_eps_ = 0;
  clear_has_oscillation_v_eps();
}
inline double Recovery::oscillation_v_eps() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_v_eps)
  return oscillation_v_eps_;
}
inline void Recovery::set_oscillation_v_eps(double value) {
  set_has_oscillation_v_eps();
  oscillation_v_eps_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_v_eps)
}

// optional double oscillation_omega_eps = 5;
inline bool Recovery::has_oscillation_omega_eps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Recovery::set_has_oscillation_omega_eps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Recovery::clear_has_oscillation_omega_eps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Recovery::clear_oscillation_omega_eps() {
  oscillation_omega_eps_ = 0;
  clear_has_oscillation_omega_eps();
}
inline double Recovery::oscillation_omega_eps() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_omega_eps)
  return oscillation_omega_eps_;
}
inline void Recovery::set_oscillation_omega_eps(double value) {
  set_has_oscillation_omega_eps();
  oscillation_omega_eps_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_omega_eps)
}

// optional double oscillation_recovery_min_duration = 6;
inline bool Recovery::has_oscillation_recovery_min_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Recovery::set_has_oscillation_recovery_min_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Recovery::clear_has_oscillation_recovery_min_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Recovery::clear_oscillation_recovery_min_duration() {
  oscillation_recovery_min_duration_ = 0;
  clear_has_oscillation_recovery_min_duration();
}
inline double Recovery::oscillation_recovery_min_duration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_recovery_min_duration)
  return oscillation_recovery_min_duration_;
}
inline void Recovery::set_oscillation_recovery_min_duration(double value) {
  set_has_oscillation_recovery_min_duration();
  oscillation_recovery_min_duration_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_recovery_min_duration)
}

// optional double oscillation_filter_duration = 7;
inline bool Recovery::has_oscillation_filter_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Recovery::set_has_oscillation_filter_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Recovery::clear_has_oscillation_filter_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Recovery::clear_oscillation_filter_duration() {
  oscillation_filter_duration_ = 0;
  clear_has_oscillation_filter_duration();
}
inline double Recovery::oscillation_filter_duration() const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Recovery.oscillation_filter_duration)
  return oscillation_filter_duration_;
}
inline void Recovery::set_oscillation_filter_duration(double value) {
  set_has_oscillation_filter_duration();
  oscillation_filter_duration_ = value;
  // @@protoc_insertion_point(field_set:roborts_local_planner.Recovery.oscillation_filter_duration)
}

// -------------------------------------------------------------------

// Config

// optional .roborts_local_planner.FrameID opt_frame = 1;
inline bool Config::has_opt_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_opt_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_opt_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_opt_frame() {
  if (opt_frame_ != NULL) opt_frame_->Clear();
  clear_has_opt_frame();
}
inline const ::roborts_local_planner::FrameID& Config::_internal_opt_frame() const {
  return *opt_frame_;
}
inline const ::roborts_local_planner::FrameID& Config::opt_frame() const {
  const ::roborts_local_planner::FrameID* p = opt_frame_;
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.opt_frame)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_local_planner::FrameID*>(
      &::roborts_local_planner::_FrameID_default_instance_);
}
inline ::roborts_local_planner::FrameID* Config::release_opt_frame() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.opt_frame)
  clear_has_opt_frame();
  ::roborts_local_planner::FrameID* temp = opt_frame_;
  opt_frame_ = NULL;
  return temp;
}
inline ::roborts_local_planner::FrameID* Config::mutable_opt_frame() {
  set_has_opt_frame();
  if (opt_frame_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::FrameID>(GetArenaNoVirtual());
    opt_frame_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.opt_frame)
  return opt_frame_;
}
inline void Config::set_allocated_opt_frame(::roborts_local_planner::FrameID* opt_frame) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete opt_frame_;
  }
  if (opt_frame) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      opt_frame = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, opt_frame, submessage_arena);
    }
    set_has_opt_frame();
  } else {
    clear_has_opt_frame();
  }
  opt_frame_ = opt_frame;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.opt_frame)
}

// optional .roborts_local_planner.Trajectory trajectory_opt = 2;
inline bool Config::has_trajectory_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_trajectory_opt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_trajectory_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_trajectory_opt() {
  if (trajectory_opt_ != NULL) trajectory_opt_->Clear();
  clear_has_trajectory_opt();
}
inline const ::roborts_local_planner::Trajectory& Config::_internal_trajectory_opt() const {
  return *trajectory_opt_;
}
inline const ::roborts_local_planner::Trajectory& Config::trajectory_opt() const {
  const ::roborts_local_planner::Trajectory* p = trajectory_opt_;
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.trajectory_opt)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_local_planner::Trajectory*>(
      &::roborts_local_planner::_Trajectory_default_instance_);
}
inline ::roborts_local_planner::Trajectory* Config::release_trajectory_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.trajectory_opt)
  clear_has_trajectory_opt();
  ::roborts_local_planner::Trajectory* temp = trajectory_opt_;
  trajectory_opt_ = NULL;
  return temp;
}
inline ::roborts_local_planner::Trajectory* Config::mutable_trajectory_opt() {
  set_has_trajectory_opt();
  if (trajectory_opt_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Trajectory>(GetArenaNoVirtual());
    trajectory_opt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.trajectory_opt)
  return trajectory_opt_;
}
inline void Config::set_allocated_trajectory_opt(::roborts_local_planner::Trajectory* trajectory_opt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trajectory_opt_;
  }
  if (trajectory_opt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory_opt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory_opt, submessage_arena);
    }
    set_has_trajectory_opt();
  } else {
    clear_has_trajectory_opt();
  }
  trajectory_opt_ = trajectory_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.trajectory_opt)
}

// optional .roborts_local_planner.Robot kinematics_opt = 3;
inline bool Config::has_kinematics_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_kinematics_opt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_kinematics_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_kinematics_opt() {
  if (kinematics_opt_ != NULL) kinematics_opt_->Clear();
  clear_has_kinematics_opt();
}
inline const ::roborts_local_planner::Robot& Config::_internal_kinematics_opt() const {
  return *kinematics_opt_;
}
inline const ::roborts_local_planner::Robot& Config::kinematics_opt() const {
  const ::roborts_local_planner::Robot* p = kinematics_opt_;
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.kinematics_opt)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_local_planner::Robot*>(
      &::roborts_local_planner::_Robot_default_instance_);
}
inline ::roborts_local_planner::Robot* Config::release_kinematics_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.kinematics_opt)
  clear_has_kinematics_opt();
  ::roborts_local_planner::Robot* temp = kinematics_opt_;
  kinematics_opt_ = NULL;
  return temp;
}
inline ::roborts_local_planner::Robot* Config::mutable_kinematics_opt() {
  set_has_kinematics_opt();
  if (kinematics_opt_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Robot>(GetArenaNoVirtual());
    kinematics_opt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.kinematics_opt)
  return kinematics_opt_;
}
inline void Config::set_allocated_kinematics_opt(::roborts_local_planner::Robot* kinematics_opt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kinematics_opt_;
  }
  if (kinematics_opt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kinematics_opt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kinematics_opt, submessage_arena);
    }
    set_has_kinematics_opt();
  } else {
    clear_has_kinematics_opt();
  }
  kinematics_opt_ = kinematics_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.kinematics_opt)
}

// optional .roborts_local_planner.GoalTolerance tolerance_opt = 4;
inline bool Config::has_tolerance_opt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_tolerance_opt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_tolerance_opt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_tolerance_opt() {
  if (tolerance_opt_ != NULL) tolerance_opt_->Clear();
  clear_has_tolerance_opt();
}
inline const ::roborts_local_planner::GoalTolerance& Config::_internal_tolerance_opt() const {
  return *tolerance_opt_;
}
inline const ::roborts_local_planner::GoalTolerance& Config::tolerance_opt() const {
  const ::roborts_local_planner::GoalTolerance* p = tolerance_opt_;
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.tolerance_opt)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_local_planner::GoalTolerance*>(
      &::roborts_local_planner::_GoalTolerance_default_instance_);
}
inline ::roborts_local_planner::GoalTolerance* Config::release_tolerance_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.tolerance_opt)
  clear_has_tolerance_opt();
  ::roborts_local_planner::GoalTolerance* temp = tolerance_opt_;
  tolerance_opt_ = NULL;
  return temp;
}
inline ::roborts_local_planner::GoalTolerance* Config::mutable_tolerance_opt() {
  set_has_tolerance_opt();
  if (tolerance_opt_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::GoalTolerance>(GetArenaNoVirtual());
    tolerance_opt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.tolerance_opt)
  return tolerance_opt_;
}
inline void Config::set_allocated_tolerance_opt(::roborts_local_planner::GoalTolerance* tolerance_opt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tolerance_opt_;
  }
  if (tolerance_opt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tolerance_opt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tolerance_opt, submessage_arena);
    }
    set_has_tolerance_opt();
  } else {
    clear_has_tolerance_opt();
  }
  tolerance_opt_ = tolerance_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.tolerance_opt)
}

// optional .roborts_local_planner.Obstacles obstacles_opt = 5;
inline bool Config::has_obstacles_opt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Config::set_has_obstacles_opt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Config::clear_has_obstacles_opt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Config::clear_obstacles_opt() {
  if (obstacles_opt_ != NULL) obstacles_opt_->Clear();
  clear_has_obstacles_opt();
}
inline const ::roborts_local_planner::Obstacles& Config::_internal_obstacles_opt() const {
  return *obstacles_opt_;
}
inline const ::roborts_local_planner::Obstacles& Config::obstacles_opt() const {
  const ::roborts_local_planner::Obstacles* p = obstacles_opt_;
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.obstacles_opt)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_local_planner::Obstacles*>(
      &::roborts_local_planner::_Obstacles_default_instance_);
}
inline ::roborts_local_planner::Obstacles* Config::release_obstacles_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.obstacles_opt)
  clear_has_obstacles_opt();
  ::roborts_local_planner::Obstacles* temp = obstacles_opt_;
  obstacles_opt_ = NULL;
  return temp;
}
inline ::roborts_local_planner::Obstacles* Config::mutable_obstacles_opt() {
  set_has_obstacles_opt();
  if (obstacles_opt_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Obstacles>(GetArenaNoVirtual());
    obstacles_opt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.obstacles_opt)
  return obstacles_opt_;
}
inline void Config::set_allocated_obstacles_opt(::roborts_local_planner::Obstacles* obstacles_opt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete obstacles_opt_;
  }
  if (obstacles_opt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      obstacles_opt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, obstacles_opt, submessage_arena);
    }
    set_has_obstacles_opt();
  } else {
    clear_has_obstacles_opt();
  }
  obstacles_opt_ = obstacles_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.obstacles_opt)
}

// optional .roborts_local_planner.Optimization optimize_info = 6;
inline bool Config::has_optimize_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Config::set_has_optimize_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Config::clear_has_optimize_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Config::clear_optimize_info() {
  if (optimize_info_ != NULL) optimize_info_->Clear();
  clear_has_optimize_info();
}
inline const ::roborts_local_planner::Optimization& Config::_internal_optimize_info() const {
  return *optimize_info_;
}
inline const ::roborts_local_planner::Optimization& Config::optimize_info() const {
  const ::roborts_local_planner::Optimization* p = optimize_info_;
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.optimize_info)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_local_planner::Optimization*>(
      &::roborts_local_planner::_Optimization_default_instance_);
}
inline ::roborts_local_planner::Optimization* Config::release_optimize_info() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.optimize_info)
  clear_has_optimize_info();
  ::roborts_local_planner::Optimization* temp = optimize_info_;
  optimize_info_ = NULL;
  return temp;
}
inline ::roborts_local_planner::Optimization* Config::mutable_optimize_info() {
  set_has_optimize_info();
  if (optimize_info_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Optimization>(GetArenaNoVirtual());
    optimize_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.optimize_info)
  return optimize_info_;
}
inline void Config::set_allocated_optimize_info(::roborts_local_planner::Optimization* optimize_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete optimize_info_;
  }
  if (optimize_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      optimize_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, optimize_info, submessage_arena);
    }
    set_has_optimize_info();
  } else {
    clear_has_optimize_info();
  }
  optimize_info_ = optimize_info;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.optimize_info)
}

// optional .roborts_local_planner.HomotopyClassPlanner hcp_opt = 7;
inline bool Config::has_hcp_opt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Config::set_has_hcp_opt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Config::clear_has_hcp_opt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Config::clear_hcp_opt() {
  if (hcp_opt_ != NULL) hcp_opt_->Clear();
  clear_has_hcp_opt();
}
inline const ::roborts_local_planner::HomotopyClassPlanner& Config::_internal_hcp_opt() const {
  return *hcp_opt_;
}
inline const ::roborts_local_planner::HomotopyClassPlanner& Config::hcp_opt() const {
  const ::roborts_local_planner::HomotopyClassPlanner* p = hcp_opt_;
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.hcp_opt)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_local_planner::HomotopyClassPlanner*>(
      &::roborts_local_planner::_HomotopyClassPlanner_default_instance_);
}
inline ::roborts_local_planner::HomotopyClassPlanner* Config::release_hcp_opt() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.hcp_opt)
  clear_has_hcp_opt();
  ::roborts_local_planner::HomotopyClassPlanner* temp = hcp_opt_;
  hcp_opt_ = NULL;
  return temp;
}
inline ::roborts_local_planner::HomotopyClassPlanner* Config::mutable_hcp_opt() {
  set_has_hcp_opt();
  if (hcp_opt_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::HomotopyClassPlanner>(GetArenaNoVirtual());
    hcp_opt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.hcp_opt)
  return hcp_opt_;
}
inline void Config::set_allocated_hcp_opt(::roborts_local_planner::HomotopyClassPlanner* hcp_opt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hcp_opt_;
  }
  if (hcp_opt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hcp_opt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hcp_opt, submessage_arena);
    }
    set_has_hcp_opt();
  } else {
    clear_has_hcp_opt();
  }
  hcp_opt_ = hcp_opt;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.hcp_opt)
}

// repeated .roborts_local_planner.FootprintModel robot_type = 8;
inline int Config::robot_type_size() const {
  return robot_type_.size();
}
inline void Config::clear_robot_type() {
  robot_type_.Clear();
}
inline ::roborts_local_planner::FootprintModel* Config::mutable_robot_type(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.robot_type)
  return robot_type_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::FootprintModel >*
Config::mutable_robot_type() {
  // @@protoc_insertion_point(field_mutable_list:roborts_local_planner.Config.robot_type)
  return &robot_type_;
}
inline const ::roborts_local_planner::FootprintModel& Config::robot_type(int index) const {
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.robot_type)
  return robot_type_.Get(index);
}
inline ::roborts_local_planner::FootprintModel* Config::add_robot_type() {
  // @@protoc_insertion_point(field_add:roborts_local_planner.Config.robot_type)
  return robot_type_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::roborts_local_planner::FootprintModel >&
Config::robot_type() const {
  // @@protoc_insertion_point(field_list:roborts_local_planner.Config.robot_type)
  return robot_type_;
}

// optional .roborts_local_planner.Recovery recovery_info = 9;
inline bool Config::has_recovery_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Config::set_has_recovery_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Config::clear_has_recovery_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Config::clear_recovery_info() {
  if (recovery_info_ != NULL) recovery_info_->Clear();
  clear_has_recovery_info();
}
inline const ::roborts_local_planner::Recovery& Config::_internal_recovery_info() const {
  return *recovery_info_;
}
inline const ::roborts_local_planner::Recovery& Config::recovery_info() const {
  const ::roborts_local_planner::Recovery* p = recovery_info_;
  // @@protoc_insertion_point(field_get:roborts_local_planner.Config.recovery_info)
  return p != NULL ? *p : *reinterpret_cast<const ::roborts_local_planner::Recovery*>(
      &::roborts_local_planner::_Recovery_default_instance_);
}
inline ::roborts_local_planner::Recovery* Config::release_recovery_info() {
  // @@protoc_insertion_point(field_release:roborts_local_planner.Config.recovery_info)
  clear_has_recovery_info();
  ::roborts_local_planner::Recovery* temp = recovery_info_;
  recovery_info_ = NULL;
  return temp;
}
inline ::roborts_local_planner::Recovery* Config::mutable_recovery_info() {
  set_has_recovery_info();
  if (recovery_info_ == NULL) {
    auto* p = CreateMaybeMessage<::roborts_local_planner::Recovery>(GetArenaNoVirtual());
    recovery_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:roborts_local_planner.Config.recovery_info)
  return recovery_info_;
}
inline void Config::set_allocated_recovery_info(::roborts_local_planner::Recovery* recovery_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete recovery_info_;
  }
  if (recovery_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      recovery_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, recovery_info, submessage_arena);
    }
    set_has_recovery_info();
  } else {
    clear_has_recovery_info();
  }
  recovery_info_ = recovery_info;
  // @@protoc_insertion_point(field_set_allocated:roborts_local_planner.Config.recovery_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace roborts_local_planner

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::roborts_local_planner::FootprintModel_FootprintType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::roborts_local_planner::FootprintModel_FootprintType>() {
  return ::roborts_local_planner::FootprintModel_FootprintType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_timed_5felastic_5fband_2eproto
